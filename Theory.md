# <span style="background-color:chocolate">ОБЩИЕ ЗАМЕТКИ</span><br>
<span style="background-color: green">Можно скомпилиривать как при помощи gcc, так и cc - второй создаст файл a.out. Или, как у gcc, можно добавить флаг -o и скомпилить файл с нужным именем.</span>

C имеет две потенциальные _<span style="color:orange">_среды выполнения_:
1. <span style="color:orange">_минимальную_ - freestanding</span>
2. <span style="color:orange">_полноценную_ - hosted</span><br>

<span style="background-color:red; color:black">---Минимальная среда выполнения---</span>
1. Может существовать вне ОС
2. Используется в создании встраиваемых систем
3. Предоставляет минимальный набор библиотечных функций, а объявление точки входа отличается в разных реализациях

Программы на C состоят из <span style="color:orange">_процедур (функций, методов)_</span>, которые:
1. имеют определённый тип и могут возвращять определённые значения (тип функции = тип возвращаемого значения)
2. могут принимать аргументы

# <span style = "background-color:chocolate">ВВЕДЕНИЕ В C</span>

## <span style="background-color:green">Директивы препроцессора</span><br>

<span style="color:violet">__Директива препроцессора__</span> — это специальная команда, которую препроцессор распознаёт и выполняет для предварительной обработки текста программы. Препроцессор обрабатывает исходный код до компиляции, и директивы указывают, как выполнять определённые действия. <br>
<span style="color:violet">__#include__</span> - ведет себя так, будто вместо нее подставляется содержимое указанного файла. По сути, подключает нужный файл.

## <span style="background-color:green">Стандартные библиотеки</span><br>

<span style="color:violet">__stdio.h__</span> - I/O - содержит методы ввода/вывода.<br>
<span style="color:violet">__stdlib.h__</span> - функции общего назначения.<br>
<span style="color:violet">__stdbool.h__</span> - для использования логического типа <span style="color:orange">__Bool_</span>.<br>
<span style="color:violet">__wchar.h__</span> - для более глубокой работы с широкими символами <span style="color:orange">__Bool_</span>.<br>

## <span style="background-color:green">Входная точка программы</span>

<span style="color:violet">__int main()__</span>  - входная точка программы<br>
<span style="color:violet">__(void)__</span> - даёт понять, что main <span style="color:orange">_ничего не принимает._</span>

Предназанчение возаращемого функцией main значения - <span style="color:orange">_указать, как завершилась программа - успешно или нет_</span>

### <span style="background-color:red; color:black">---Как происходит вход/выход в/из программы:---</span><br>

#### ВХОД 
main - входная точка, выполняемая при запуске программы
выполняется функция main в серверной среде, после запуска из командной строки или другой программы

#### ВЫХОД 
return (0 или 1, или макросы, представляющие эти значения) - выход из программы -- среда исполнения получает возврат из функции main, по которому может проверить состояние проги и определить, насколько успешен был вызов.

#### ЗАМЕЧАНИЯ 
return __value__ в main = exit(__value__) 

## <span style="background-color:green">ФОРМАТИРОВАННЫЙ ВЫВОД</span><br>

<span style="color:violet">__printf__</span> (или ее вариации) - функция, для форматированного вывода. Принимает строку, которая описывет формат вывода и произвольное количество аргументов, представляющих значения для вывода. Сама же возвращает количество выведенных символов, а при возникновении ошибки — отрицательное значение 
> <span style="color:red">АЛАРМ! ОПАСНОСТЬ! Никогда пользовательские данные не должны быть первым аргументом функции (т.е. как строку формата), т.к это может привести к утечкам памяти или инфы. Например:

```c
int main() {
    char buffer[100];
    
    // Симуляция ввода злоумышленника
    char *malicious_input = "%08x %08x %08x %08x";
    
    printf("=== УЯЗВИМЫЙ ВЫЗОВ ===\n");
    printf(malicious_input);  // ОПАСНО!
    printf("\n");
    
    printf("=== БЕЗОПАСНЫЙ ВЫЗОВ ===\n");
    printf("%s", malicious_input);  // БЕЗОПАСНО
    printf("\n");
    
    return 0;
}
```

>Вывод уязвимой версии может показать:
0041a2c0 00000001 7ffd42a8 0041a2c0
(это служебные данные из стека - УТЕЧКА ИНФОРМАЦИИ!)
</span>

### <span style="background-color:red; color:black">__Спецификаторы формата__</span> (не все)
1. <span style="color:violet">__%s__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_строку_</span>
2. <span style="color:violet">__%d__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_целое число_</span>
3. <span style="color:violet">__%f__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_число с плавающей точкой_</span>
4. <span style="color:violet">__%c__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_символ_</span>
5. <span style="color:violet">__%x__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_шестнадцатиричное число_</span>

### <span style="background-color:red; color:black">Алфавитные управляющие последовательности</span>
Необходимы для вывода неотображаемых символов. Список последовательностей:
1. <span style="color:violet">__\n__</span> - перевод строки

## <span style="background-color:green">БИБЛИОТЕЧНЫЕ МЕТОДЫ И МАКРОСЫ</span>

<span style="color:violet">__int puts(const char*)__</span>
1. записывает полученный аргумент в поток <span style="color:orange">_stdout (консоль или терминал)_</span>, добавляя к выводу '\n'
2. если во время вывода возникла ошибка, возвращается макрос EOF (представляющий отрицательное число) - иначе целое неотрицательное значение
    
<span style="color:violet">__EXIT_SUCCESS__</span>
1. макрос, зачастую имеет такое определение - #define EXIT_SUCCESS 0

<span style="color:violet">__EOF__</span>
1. макрос

## <span style="background-color:green">КОМПИЛЯТОРЫ</span>
### <span style="background-color:red; color:black">GNU Compiler Collection</span>
<span style="color:violet">__GCC__</span> — стандартный компилятор в системах Linux (также есть версии для других платформ). Поддерживает <span style="color:orange">_C_</span>, <span style="color:orange">_C++_</span>, <span style="color:orange">_Objective-C_</span> и другие языки<br>

### <span style="background-color:red; color:black">Clang</span>
<span style="color:violet">__Clang__</span> — фронтенд для компиляторов для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, созданный совместно с фреймворком LLVM. Цель проекта — <span style="color:orange">_создание замены GNU Compiler Collection (GCC)_</span>.<br>

### <span style="background-color:red; color:black">MICROSOFT VISUAL STDUIO</span>
<span style="color:violet">__Microsoft Visual Studio__</span> — не столько компилятор, сколько <span style="color:orange">_самая популярная IDE для C/C++ на Windows_</span>, но поставляется вместе с компилятором для C/C++<br>

### <span style="background-color:red; color:black">Переносимость</span>
Компиляторы не поддерживают весь спектр спецификаций стандарта C (в том числе и промежуточных). В целом, <span style="color:orange">_реа­лизации C развиваются медленно, и многие компиляторы существенно отстают от стандарта языка_</span>.

1. <span style="color:orange">_Идеал vs Реальность_</span>: Программы на C в идеале должны строго следовать стандарту для максимальной переносимости. На практике это недостижимо.

2. <span style="color:orange">_Практический подход_</span>: В реальности код пишут для конкретных реализаций (платформ), что позволяет использовать их особенности и не мешает работе на нескольких платформах.

3. <span style="color:orange">_Проблемы переносимости_</span>: Стандарт C явно выделяет пять видов поведения, которые мешают переносимости:

- <span style="color:orange">_Поведение, определяемое реализацией (во избежание проблем, нужно стремиться писать код, поведение которого не будет зависеть от конкретной реализации языка (стандарт языка и компилятор))_</span>
- <span style="color:orange">_Неуточнённое поведение (стандарт C допускает несколько вариантов работы программы, но не указывает, какой именно должен быть выбран -> т.е. все варианты корректны, но результат выполнения - разный)_</span>
- <span style="color:orange">_Неопределённое поведение_</span>
- <span style="color:orange">_Поведение, зависящее от региональных параметров_</span>
- <span style="color:orange">_Распространённые расширения_</span>

#### <span style="background-color:red">Неопределенное поведение</span>
<span style="color:violet">__Неопределённое поведение__</span> - поведение, для которого стандарт C не устанавливает никаких требований.

<span style="color:red">Сущность</span>:<br>

1. Результат непредсказуем — от некорректного вывода до сбоя программы

2. Примеры: переполнение знакового целого, разыменование некорректного указателя

3. Стандарт явно не определяет последствия таких действий

<span style="color:red">Возможные последствия:</span>:<br>

1. Непредсказуемые результаты без предупреждений

2. Поведение, специфичное для конкретной платформы

3. Аварийное завершение программы

<span style="background-color:red; color: black">__АЛАРМ!__</span> Нужно избегать неопределённого поведения, если только реализация явно не определяет его через расширения языка.</span>

# <span style="background-color:chocolate">ОБЪЕКТЫ, ФУНКЦИИ И ТИПЫ</span><br>

## <span style="background-color:green">ОБЪЕКТЫ</span>
<span style="color:violet">__Объект__</span> — это хранилище, в котором можно представлять значения. По стандарту <span style="color:orange">_ISO/IEC 9899:2018_</span>, <span style="color:violet">__объект__</span> - область хранилища данных в среде выполнения, содержимое которого может представлять значения» с примечанием: «при обращении к объекту можно считать, что он обладает определенным типом». Один из примеров объекта - <span style="color:orange">_переменная_</span>.

<span style="color:violet">__Переменная__</span> - это контейнер для значения. Они имеют объявленный <span style="color:orange">_тип_</span>, указывающий на то, какого рода объект представляет его значение, а также <span style="color:orange">_имя_</span> - идентификатор, по которому можно обратиться к созданной переменной.

У объектов есть понятие <span style="color:violet">__времени жизни__</span> или, как в других языках, <span style="color:violet">__жизненного цикла__</span> - это период выполнения программы, во время которого объект существует. Вне периода к объекту обратиться нельхя, т.к. он уже не будет существовать.

<span style="color:orange">_Время хранения_</span> определяет <span style="color:orange">_время жизни_</span> объекта.

## <span style="background-color:green">ТИПЫ</span>

<span style="color:violet">__Тип__</span> - характеристика данных, определяющая размер выделяемой для объекта памяти и представление объекта в памяти, допустимые с объектом операции и его диапозон значений.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Каждый тип в С является либо <span style="color:orange">_объектным_</span>, либо <span style="color:orange">_функциональным_</span>.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Важность типа объясняется тем, что набор битов, представляющий объект определённого типа, будет иметь другое значение, если интерпретировать как объект другого типа. 

> <span style="background-color:#00a572; color: white">__Пример__</span> В IEEE 754 (стандарт IEEE для арифметических операций с плавающей запятой) число 1 можно представить как 0x3f800000 (IEEE 754–2008). Этим же набором битов, интерпретированным как целое число, можно представить число 1 065 353 216.

<span style="color:orange">_Базовые типы_</span>:

1. <span style="color: violet">int</span> - целочисленный
2. <span style="color: violet">float</span> - вещественный
3. <span style="color: violet">char</span> - символьный
4. <span style="color: violet">void</span> - пустой тип (функция с этим типом будет считаться бестиповой)

### <span style="background-color:green">ОБЪЕКТНЫЕ ТИПЫ</span>
Делятся на логические, символьные и численные типы

#### <span style="background-color:green">ЛОГИЧЕСКИЕ ТИПЫ</span>
Могут хранить либо 0, либо 1. 
<span style="color: violet">Лочиеский тип (булевый, _Bool)</span> впервые появился в C99, начинается с подчёркивания, чтобы не возникало путаницы с пользовательскими идентификаторами bool и boolean, которые были объявлены в существующихх программах. 

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если название начинается с нижнего подчеркивания и заглавной буквы следом, то оно считается <span style="color:orange">_зарезервированным_</span>.  

Может быть использован при подключении заголовочного файла <span style="color:orange">_stdbool.h_</span>.
>Пример в functions_objects_and_types/jokes_with_types.c

Можно объявлять как при помощи <span style="color:orange">__Bool_</span>, так и <span style="color:orange">_bool_</span>, но лучше использовать bool, так как именно ему отдаётся предпочтение в долгосрочной перспективе. При присвоении значения true, это значение разворачивается в целочисленную константу 1, а при присвоении false - в 0.

#### <span style="background-color:green">СИМВОЛЬНЫЕ ТИПЫ</span>
Есть три символьных типа:

1. <span style="color: violet">__char__</span>
2. <span style="color: violet">__unsigned char__</span>
3. <span style="color: violet">__signed char__</span>

В любой реализации, char имеет одинаковые с unsigned char или signed char (зависит от реализации) <span style="color:orange">_выравнивание_</span>, <span style="color:orange">_размер_</span>, <span style="color:orange">_диапазон_</span>, <span style="color:orange">_представление_</span> и <span style="color:orange">_поведение_</span>. Но при этом char - <span style="color:orange">_отдельный тип_</span>, не совместимый с другими символьными типами.

Обычно используется тип char для представления символьных данных. Объекты этого типа хранят минимальный набор символов, необходимых среде выполнения, включая:

1.  строчные и заглавные латинские буквы
2. десятичные цифры (все от 0 до 9)
3. пробельные символы
4. знаки препинания
5. управляющие символы

Для хранения небольших целых значений со знаком или без лучше использовать <span style="color:orange">_signed char_</span> или <span style="color:orange">_unsigned char_</span>.

Широкие символы <span style="color:orange">_wchar_t_</span>:
1. Решает проблему отсутствия неанглийских букв в char
2. Поддерживает большие наборы символов
3. Обычно занимает 16 или 32 бита
4. Стандартная библиотека предоставляет функции для работы с char и wchar_t

> <span style="background-color:red; color: black">__АЛАРМ!__</span> При инициализации значения wchar_t нужно использовать <span style="color:orange">_L_</span> перед литералом строки или символа - для того, чтобы была работа именно с wchar_t, работающим с символами юникода, а также нужен <span style="color:orange">_setlocale(LC_ALL, "");_</span> - для обозначения работы с другими локалями (не английской, в данном случае - в локали окружения). Пример в functions_objects_and_types/jokes_with_types.c. Также есть функции для работы с широкими символами, например <span style="color:orange">_wprintf_</span> из библиотеки <span style="color:orange">_wchar.h_</span> - её лучше использовать для вывода несольких широких символов или при смеашанном выводе

## <span style="background-color:green">ФУНКЦИИ</span>

<span style="color: violet">Функция</span> - это именованный блок кода, который выполняет одну конкретную задачу. Может быть вызвана много раз.

У функции могут быть описаны <span style="color:violet">__параметры__</span> - объекты, которые объявляются вместе с функцией и получают значения при входе в нее, а те самые значения - есть <span style="color:violet">__аргументы__</span>. В языке C передача <span style="color:orange">__аргументов__</span> при вызове происходит <span style="color:orange">_по значению_</span>; то есть когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. Изменение значений параметров в функции не влияет на значения в вызывающем коде, поскольку это разные объекты.

Если в объявлении функции после типа указан знак *, это значит, что параметр является <span style="color:orange">_указателем_</span> на объект или функцию заданного типа.

Не объекты, но имеют тип, характеризуемый возращаемым значением и числом/типами параметров.

## <span style="background-color:green">УКАЗАТЕЛИ</span>

<span style="color:violet">__Указатель__</span> - переменная, которая хранит <span style="color:orange">_адрес памяти_</span> другой переменной или функции. <span style="color:violet"> __Адрес__</span> - область памяти, в которой хранятся объекты или функции.

<span style="color:violet">__Ссылочный тип__</span> - тип указателя, определяемый типом данных, на которые он ссылается.

<span style="background-color:red; color: black">__АЛАРМ!__</span> <span style="color:orange">_Объектные указатели_</span> (то есть указатели на объект) отличаются от <span style="color:orange">_функциональных указателей_</span> (то есть указатели на функцию) => их нельзя использовать как взаимозаменямые.

```c
void swap(int* a, int* b) {
    int temp = *a;

    *a = *b;
    *b = temp;
}
```
> int temp = *a; - унарная операция * - <span style="color:violet">__операция разыменовывания__</span>, т.е. получение значения по адресу памяти, куда указывает указатель а

```c
swap(&a, &b);
```
> унарная операция & - операция взятия адреса

```c
#include <stdlib.h>
#include <stdio.h>

void swap(int*, int*);

int main(void) {
    int a = 15, b = 71;
    printf("a = %d, b = %d до вызова функции\n", a, b);

    swap(&a, &b);
    printf("a = %d, b = %d после вызова функции\n", a, b);

    return EXIT_SUCCESS;
}

void swap(int* a, int* b) { //параметры, при вызове функции, будут содержать копии аргументов, т.е. переданных адресов - имитация передачи аргументов по ссылке
    int temp = *a;

    *a = *b;
    *b = temp;
}
```

## <span style="background-color:green">ОБЛАСТИ ВИДИМОСТИ</span>
<span style="color:violet">__Область видимости__</span> - 1) блок кода, в котором возможно обращение к идентификатору. В языке C область видимости может охватывать <span style="color:orange">_файл_</span>, <span style="color:orange">_блок кода_</span>, <span style="color:orange">_функцию_</span>, <span style="color:orange">_прототип(объявление) функции_</span>. 2) регион программы, в котором идентификатор может быть использован

Область видимости определяется местом, где он объявлен:
1. <span style="color:violet">__На уровне файла__</span>. Это значит, что идентификатор доступен на уровне всего файла, где объявлен, а также во всех других файлах, где используется файл объявления. Например, в файле source.h, в самом начале файле, после объявления заголовочного файла, мы определили макрос <span style="color:orange">_nagger_</span>, и если мы подключим этот файл в source_code.c, то мы сможем этим макросом пользоваться в .c файле.
```c
//source.h
#define nagger "NAGGER" 

//source_code.h
#include <source.h>
int main() {
    char* naggers_name = nagger;
}
```

> Макрос не имеет области видмости в общем понимании этого слова, как идентификатор, поэтому вот еще пример

```c
//source.h
void swap(int*, int*);

//source_code.h
#include <source.h>
int main() {
    int a = 0;
    int b = 1;
    swap(&a, &b);
}
```
2. <span style="color:violet">__Блочная область видимости__</span>. Объявленный идентификатор доступн только в том блоке, в котором объявлен. 
```c
int main() {
    int a = 1;
    {
        int temp = 2;
    }

    int b = temp + a; //АЛАРМ!!!!!!!! ОШИБКА!!!!!!!!!
}
``` 
3. <span style="color:violet">__Область видимости в прототипе функции__</span>. Параметры в прототипе видны только в этом прототипе.
```c
int swap(int a, int b);

int main() {
    a = 0; //АЛАРМ!!!!!!!!!!!ОШИБКА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
```
4. <span style="color:violet">__Область видимости функции__</span>. Только для меток. <span style="color:orange">_Метка_</span>, объявленная в функции, видна в любом месте этой функции.
> Про метки будет инфа чуть позже<br>
> В функции, параметры этой функции и локальные переменные имеют блочную область видимости (блоком является тело функции)

Области видимости могут быть <span style="color:orange">_вложенными_</span> и находиться как внутри, так снаружи других блоков.

При объявлении одинаковых идентификаторов в <span style="color:orange">_наружней_</span> и <span style="color:orange">_внутренней_</span> областях видимости, объявленный во внутренней будет перекрвать наружнюю версию.

## <span style="background-color:green">СРОК ХРАНЕНИЯ</span>

<span style="color:violet">__Срок хранения__</span> определяет <span style="color:orange">_время жизни_</span> объекта.

Какие есть сроки хранения:

1. <span style="color:violet">__Автоматический__</span>. Время жизни объекта начинается при выполнении блока и заканчивается вместе с выполнением блока. Например, <span style="color:orange">_параметры функции_</span>.
> Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.
2. <span style="color:violet">__Статический__</span>. Таким сроком хранения обладают объекты, объявленный на уровне файла. Время жизни = <span style="color:orange">_время выполнения программы_</span>, а значения инициализируются ещё до запуска программы.
> При помощи модификатора <span style="color:orange">_static_</span> можно задать статический срок хранения даже переменным с <span style="color:orange">_блочной видимостью_</span>. Смотри файл functions_objects_and_types/jokes_with_lifetime.c
> Статические объекты должны <span style="color:orange">_инициализироваться с помощью константного значения, а не переменной_</span> 
```c
int *func(int i) {
  const int j = i;  // правильно
  static int k = j; // ошибка
  return &k;
}
```
> К константным значениям относятся <span style="color:orange">_константы-литералы_</span> (например, 1, 'a' или 0xFF), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.
3. <span style="color:violet">__Потоковый__</span> - используется в <span style="color:orange">_конкурентном программировании_</span>.
> <span style="color:violet">__Конкурентное программирование__</span> - это подход к разработке программного обеспечения, при котором несколько вычислительных процессов выполняются одновременно, чтобы повысить эффективность и производительность систем. 
4. <span style="color:violet">__Выделенный__</span> или <span style="color:violet">__динамический__</span> - задействован в работе с динамически выделяемой памятью

<span style="background-color:red; color: black">__АЛАРМ!__</span> При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.

## <span style="background-color:green">ВЫРАВНИВАНИЕ</span>

<span style="color:violet">__Выравнивание__</span> - это требование типов объектов, ограничивающее допустимые адреса для размещения объектов. Оно определяет количество байтов между смежными адресами, при котором может быть сохранен объект данного типа. Адрес выровненных данных может быть кратен размеру объекта, и процессор может обрабатывать выровненные и невыровненные данные по-разному. 

Любой компьютер выполняет многобайтный доступ к данным по границам <span style="color:orange">_машинного слова_</span>(выровненный доступ). Однако:

1. Некоторые системы могут также обращаться к невыровненным данным с потерей производительности (либо с ошибками в результате)

2. Другие системы вообще не поддерживают невыровненный доступ"

> <span style="color:violet">__Машинное слово__</span> - естественная единица фиксированного размера для измерения данных, с которыми работают инструкции или аппаратные механизмы процессора.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Требования к выравниванию могут зависеть от размера машинного слова в конкретном процессоре (обычно это 16, 32 или 64 бита).

В целом, при программировании на C не стоит греть голову о выравнивании, но иногда бывают ситуации, когда решения компилятора о выравнивании памяти приходится переопределять - например, для выравнивания данных на границах строк кэша (адреса должны быть кратны степеням 2). Для этого можно пойти двумя способами:

1. команды компоновки;

2. выделение дополнительной памяти с помощью <span style="color:orange">_malloc_</span> с последующим округлением пользовательского адреса вверх;

3. другие нестандартные средства.

Также гарантируется, что память выделенная при помощи <span style="color:orange">_malloc_</span>, будет достаточно выравнена для всех стандартных типов (включая массивы и структуры). 

> Например, есть структура:
```c
struct nagger {
    char[20] name;
    double money;
}
```
> char[20] потребует 20 байт для хранения данных, bouble - ещё 8, итого - 28 байт на объект структуры. После выравнивания, в некоторых системах для объекта будет выделено 32 байта, а в каких-то 64 (будет округлено до степеней 2) - добавятся <span style="color:orange">_отступы_</span> либо в конец памяти, выделенной для объекта, либо меджу байтами данных <span style="color:orange">_name_</span> и <span style="color:orange">_money_</span> - чтобы поле money было выровнено по адресу, кратному 8, и тогда размер структуры составит 32 байта.

В c11 появился простой способ указания выравнивания, совместимый с будущими версиями стандарта:

1. Выравнивание представляется как неотрицательное целое число типа <span style="color:orange">_size_t_</span>.
2. Корректное выравнивание должно быть степенью двойки.

Также в c11 появился спецификатор выравнивания <span style="color:orange">__Alignas_</span>:

1. Позволяет указать, что переменная должна быть выровнена определенным образом.
> Пример в functions_objects_and_types/jokes_with_alignments.c

Строгость выравнивания:

1. Способы выравнивания упорядочены от слабых к строгим.

2. Чем строже выравнивание, тем больше его значение (т.е. больше байт).

3. Адрес, удовлетворяющий строгому выравниванию, автоматически удовлетворяет и более слабым (меньшим) выравниваниям.