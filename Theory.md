# <span style="background-color:chocolate">ОБЩИЕ ЗАМЕТКИ</span><br>
<span style="background-color: green">Можно скомпилиривать как при помощи gcc, так и cc - второй создаст файл a.out. Или, как у gcc, можно добавить флаг -o и скомпилить файл с нужным именем.</span>

C имеет две потенциальные _<span style="color:orange">_среды выполнения_:
1. <span style="color:orange">_минимальную_ - freestanding</span>
2. <span style="color:orange">_полноценную_ - hosted</span><br>

<span style="background-color:red; color:black">---Минимальная среда выполнения---</span>
1. Может существовать вне ОС
2. Используется в создании встраиваемых систем
3. Предоставляет минимальный набор библиотечных функций, а объявление точки входа отличается в разных реализациях

Программы на C состоят из <span style="color:orange">_процедур (функций, методов)_</span>, которые:
1. имеют определённый тип и могут возвращять определённые значения (тип функции = тип возвращаемого значения)
2. могут принимать аргументы

# <span style = "background-color:chocolate">ВВЕДЕНИЕ В C</span>

## <span style="background-color:green">Директивы препроцессора</span><br>

<span style="color:violet">__Директива препроцессора__</span> — это специальная команда, которую препроцессор распознаёт и выполняет для предварительной обработки текста программы. Препроцессор обрабатывает исходный код до компиляции, и директивы указывают, как выполнять определённые действия. <br>
<span style="color:violet">__#include__</span> - ведет себя так, будто вместо нее подставляется содержимое указанного файла. По сути, подключает нужный файл.

## <span style="background-color:green">Стандартные библиотеки</span><br>

<span style="color:violet">__stdio.h__</span> - I/O - содержит методы ввода/вывода<br>
<span style="color:violet">__stdlib.h__</span> - функции общего назначения<br>
<span style="color:violet">__stdbool.h__</span> - для использования логического типа <span style="color:orange">__Bool_</span>.<br>
<span style="color:violet">__wchar.h__</span> - для более глубокой работы с <span style="color:orange">_широкими символами_</span><br>
<span style="color:violet">__limits.h__</span> - файл, который определяет константы, связанные с ограничениями типов данных<br>
<span style="color:violet">__stdint.h__</span> - файл, позволяющий работать с целочисленными типами<br>
<span style="color:violet">__inttypes.h__</span> - файл, который определяет константы, связанные с ограничениями типов данных<br>
<span style="color:violet">__string.h__</span> - файл, предоставляющий функции для работы со строками<br>

## <span style="background-color:green">Входная точка программы</span>

<span style="color:violet">__int main(void)__</span>  - входная точка программы<br>
<span style="color:violet">__(void)__</span> - даёт понять, что функция <span style="color:orange">_ничего не принимает._</span>

Предназанчение возаращемого функцией main значения - <span style="color:orange">_указать, как завершилась программа - успешно или нет_</span>

### <span style="background-color:red; color:black">---Как происходит вход/выход в/из программы:---</span><br>

#### ВХОД 
main - входная точка, выполняемая при запуске программы
выполняется функция main в серверной среде, после запуска из командной строки или другой программы

#### ВЫХОД 
return (0 или 1, или макросы, представляющие эти значения) - выход из программы -- среда исполнения получает возврат из функции main, по которому может проверить состояние проги и определить, насколько успешен был вызов.

#### ЗАМЕЧАНИЯ 
return __value__ в main = exit(__value__) 

## <span style="background-color:green">ФОРМАТИРОВАННЫЙ ВЫВОД</span><br>

<span style="color:violet">__printf__</span> (или ее вариации) - функция, для форматированного вывода. Принимает строку, которая описывет формат вывода и произвольное количество аргументов, представляющих значения для вывода. Сама же возвращает количество выведенных символов, а при возникновении ошибки — отрицательное значение 
> <span style="color:red">АЛАРМ! ОПАСНОСТЬ! Никогда пользовательские данные не должны быть первым аргументом функции (т.е. как строку формата), т.к это может привести к утечкам памяти или инфы. Например:

```c
int main() {
    char buffer[100];
    
    // Симуляция ввода злоумышленника
    char *malicious_input = "%08x %08x %08x %08x";
    
    printf("=== УЯЗВИМЫЙ ВЫЗОВ ===\n");
    printf(malicious_input);  // ОПАСНО!
    printf("\n");
    
    printf("=== БЕЗОПАСНЫЙ ВЫЗОВ ===\n");
    printf("%s", malicious_input);  // БЕЗОПАСНО
    printf("\n");
    
    return 0;
}
```

>Вывод уязвимой версии может показать:
0041a2c0 00000001 7ffd42a8 0041a2c0
(это служебные данные из стека - УТЕЧКА ИНФОРМАЦИИ!)
</span>

### <span style="background-color:red; color:black">__Спецификаторы формата__</span> (не все)
1. <span style="color:violet">__%s__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_строку_</span>
2. <span style="color:violet">__%d__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_целое число_</span>
3. <span style="color:violet">__%f__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_число с плавающей точкой_</span>
4. <span style="color:violet">__%c__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_символ_</span>
5. <span style="color:violet">__%x__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_шестнадцатиричное число_</span>
6. <span style="color:violet">__%u__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_беззнаковое целое число_</span>

### <span style="background-color:red; color:black">Алфавитные управляющие последовательности</span>
Необходимы для вывода неотображаемых символов. Список последовательностей:
1. <span style="color:violet">__\n__</span> - перевод строки

## <span style="background-color:green">БИБЛИОТЕЧНЫЕ МЕТОДЫ И МАКРОСЫ</span>

<span style="color:violet">__int puts(const char*)__</span>
1. записывает полученный аргумент в поток <span style="color:orange">_stdout (консоль или терминал)_</span>, добавляя к выводу '\n'
2. если во время вывода возникла ошибка, возвращается макрос EOF (представляющий отрицательное число) - иначе целое неотрицательное значение
    
<span style="color:violet">__EXIT_SUCCESS__</span>
1. макрос, зачастую имеет такое определение - #define EXIT_SUCCESS 0

<span style="color:violet">__EOF__</span>
1. макрос

<span style="color:violet">__char *strcpy (char *__restrict __dest, const char *__restrict __src)__</span>
Копирует в <span style="color:orange">_dest_</span> значение <span style="color:orange">_src_</span>. Аналог для широких символов <span style="color:violet">__wcscpy__</span>

## <span style="background-color:green">КОМПИЛЯТОРЫ</span>
### <span style="background-color:red; color:black">GNU Compiler Collection</span>
<span style="color:violet">__GCC__</span> — стандартный компилятор в системах Linux (также есть версии для других платформ). Поддерживает <span style="color:orange">_C_</span>, <span style="color:orange">_C++_</span>, <span style="color:orange">_Objective-C_</span> и другие языки<br>

### <span style="background-color:red; color:black">Clang</span>
<span style="color:violet">__Clang__</span> — фронтенд для компиляторов для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, созданный совместно с фреймворком LLVM. Цель проекта — <span style="color:orange">_создание замены GNU Compiler Collection (GCC)_</span>.<br>

### <span style="background-color:red; color:black">MICROSOFT VISUAL STDUIO</span>
<span style="color:violet">__Microsoft Visual Studio__</span> — не столько компилятор, сколько <span style="color:orange">_самая популярная IDE для C/C++ на Windows_</span>, но поставляется вместе с компилятором для C/C++<br>

### <span style="background-color:red; color:black">Переносимость</span>
Компиляторы не поддерживают весь спектр спецификаций стандарта C (в том числе и промежуточных). В целом, <span style="color:orange">_реа­лизации C развиваются медленно, и многие компиляторы существенно отстают от стандарта языка_</span>.

1. <span style="color:orange">_Идеал vs Реальность_</span>: Программы на C в идеале должны строго следовать стандарту для максимальной переносимости. На практике это недостижимо.

2. <span style="color:orange">_Практический подход_</span>: В реальности код пишут для конкретных реализаций (платформ), что позволяет использовать их особенности и не мешает работе на нескольких платформах.

3. <span style="color:orange">_Проблемы переносимости_</span>: Стандарт C явно выделяет пять видов поведения, которые мешают переносимости:

- <span style="color:orange">_Поведение, определяемое реализацией (во избежание проблем, нужно стремиться писать код, поведение которого не будет зависеть от конкретной реализации языка (стандарт языка и компилятор))_</span>
- <span style="color:orange">_Неуточнённое поведение (стандарт C допускает несколько вариантов работы программы, но не указывает, какой именно должен быть выбран -> т.е. все варианты корректны, но результат выполнения - разный)_</span>
- <span style="color:orange">_Неопределённое поведение_</span>
- <span style="color:orange">_Поведение, зависящее от региональных параметров_</span>
- <span style="color:orange">_Распространённые расширения_</span>

#### <span style="background-color:red">Неопределенное поведение</span>
<span style="color:violet">__Неопределённое поведение__</span> - поведение, для которого стандарт C не устанавливает никаких требований.

<span style="color:red">Сущность</span>:<br>

1. Результат непредсказуем — от некорректного вывода до сбоя программы

2. Примеры: переполнение знакового целого, разыменование некорректного указателя

3. Стандарт явно не определяет последствия таких действий

<span style="color:red">Возможные последствия:</span>:<br>

1. Непредсказуемые результаты без предупреждений

2. Поведение, специфичное для конкретной платформы

3. Аварийное завершение программы

<span style="background-color:red; color: black">__АЛАРМ!__</span> Нужно избегать неопределённого поведения, если только реализация явно не определяет его через расширения языка.</span>

# <span style="background-color:chocolate">ОБЪЕКТЫ, ФУНКЦИИ И ТИПЫ</span><br>

## <span style="background-color:green">ОБЪЕКТЫ</span>
<span style="color:violet">__Объект__</span> — это хранилище, в котором можно представлять значения. По стандарту <span style="color:orange">_ISO/IEC 9899:2018_</span>, <span style="color:violet">__объект__</span> - область хранилища данных в среде выполнения, содержимое которого может представлять значения» с примечанием: «при обращении к объекту можно считать, что он обладает определенным типом». Один из примеров объекта - <span style="color:orange">_переменная_</span>.

<span style="color:violet">__Переменная__</span> - это контейнер для значения. Они имеют объявленный <span style="color:orange">_тип_</span>, указывающий на то, какого рода объект представляет его значение, а также <span style="color:orange">_имя_</span> - идентификатор, по которому можно обратиться к созданной переменной.

У объектов есть понятие <span style="color:violet">__времени жизни__</span> или, как в других языках, <span style="color:violet">__жизненного цикла__</span> - это период выполнения программы, во время которого объект существует. Вне периода к объекту обратиться нельхя, т.к. он уже не будет существовать.

<span style="color:orange">_Время хранения_</span> определяет <span style="color:orange">_время жизни_</span> объекта.

## <span style="background-color:green">ТИПЫ (СОВМЕЩЕНО С ГЛАВОЙ 3)</span>

<span style="color:violet">__Тип__</span> - характеристика данных, определяющая размер выделяемой для объекта памяти и представление объекта в памяти, допустимые с объектом операции и его диапозон значений.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Каждый тип в С является либо <span style="color:orange">_объектным_</span>, либо <span style="color:orange">_функциональным_</span>.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Важность типа объясняется тем, что набор битов, представляющий объект определённого типа, будет иметь другое значение, если интерпретировать как объект другого типа. 

> <span style="background-color:#00a572; color: white">__Пример__</span> В IEEE 754 (стандарт IEEE для арифметических операций с плавающей запятой) число 1 можно представить как 0x3f800000 (IEEE 754–2008). Этим же набором битов, интерпретированным как целое число, можно представить число 1 065 353 216.

<span style="color:orange">_Базовые типы_</span>:

1. <span style="color: violet">int</span> - целочисленный
2. <span style="color: violet">float</span> - вещественный
3. <span style="color: violet">char</span> - символьный
4. <span style="color: violet">void</span> - пустой тип (функция с этим типом будет считаться бестиповой)

### <span style="background-color:green">ОБЪЕКТНЫЕ ТИПЫ</span>
Делятся на логические, символьные и численные типы

#### <span style="background-color:green">ЛОГИЧЕСКИЕ ТИПЫ</span>
Могут хранить либо 0, либо 1. 
<span style="color: violet">Лочиеский тип (булевый, _Bool)</span> впервые появился в C99, начинается с подчёркивания, чтобы не возникало путаницы с пользовательскими идентификаторами bool и boolean, которые были объявлены в существующихх программах. 

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если название начинается с нижнего подчеркивания и заглавной буквы следом, то оно считается <span style="color:orange">_зарезервированным_</span>.  

Может быть использован при подключении заголовочного файла <span style="color:orange">_stdbool.h_</span>.
>Пример в functions_objects_and_types/jokes_with_types.c

Можно объявлять как при помощи <span style="color:orange">__Bool_</span>, так и <span style="color:orange">_bool_</span>, но лучше использовать bool, так как именно ему отдаётся предпочтение в долгосрочной перспективе. При присвоении значения true, это значение разворачивается в целочисленную константу 1, а при присвоении false - в 0.

#### <span style="background-color:green">СИМВОЛЬНЫЕ ТИПЫ</span>
Есть три символьных типа:

1. <span style="color: violet">__char__</span>
2. <span style="color: violet">__unsigned char__</span>
3. <span style="color: violet">__signed char__</span>

В любой реализации, char имеет одинаковые с unsigned char или signed char (зависит от реализации) <span style="color:orange">_выравнивание_</span>, <span style="color:orange">_размер_</span>, <span style="color:orange">_диапазон_</span>, <span style="color:orange">_представление_</span> и <span style="color:orange">_поведение_</span>. Но при этом char - <span style="color:orange">_отдельный тип_</span>, не совместимый с другими символьными типами.

Обычно используется тип char для представления символьных данных. Объекты этого типа хранят минимальный набор символов, необходимых среде выполнения, включая:

1.  строчные и заглавные латинские буквы
2. десятичные цифры (все от 0 до 9)
3. пробельные символы
4. знаки препинания
5. управляющие символы

Для хранения небольших целых значений со знаком или без лучше использовать <span style="color:orange">_signed char_</span> или <span style="color:orange">_unsigned char_</span>.

Широкие символы <span style="color:orange">_wchar_t_</span>:
1. Решает проблему отсутствия неанглийских букв в char
2. Поддерживает большие наборы символов
3. Обычно занимает 16 или 32 бита
4. Стандартная библиотека предоставляет функции для работы с char и wchar_t

> <span style="background-color:red; color: black">__АЛАРМ!__</span> При инициализации значения wchar_t нужно использовать <span style="color:orange">_L_</span> перед литералом строки или символа - для того, чтобы была работа именно с wchar_t, работающим с символами юникода, а также нужен <span style="color:orange">_setlocale(LC_ALL, "");_</span> - для обозначения работы с другими локалями (не английской, в данном случае - в локали окружения). Также есть функции для работы с широкими символами, например <span style="color:orange">_wprintf_</span> из библиотеки <span style="color:orange">_wchar.h_</span> - её лучше использовать для вывода нескольких широких символов или при смешанном выводе

> <span style="background-color:red; color: black">__АЛАРМ v2!__</span> Одновременно использовать <span style="color:orange">_printf_</span> и <span style="color:orange">_wprintf_</span> нельзя - после использования <span style="color:orange">_printf_</span> выходной поток переходит в <span style="color:orange">_байтовый_</span> режим (а не <span style="color:orange">_широкий_</span>), соответственно, нужно использовать какую-то одну - или <span style="color:orange">_printf_</span>, или <span style="color:orange">_wprintf_</span>.

> Примеры в functions_objects_and_types/jokes_with_types.c.

#### <span style="background-color:green">ЧИСЛЕННЫЕ ТИПЫ</span>

##### <span style="background-color:green">ЦЕЛОЧИСЛЕННЫЕ ТИПЫ</span>

Используются для представления отрицательных и положительных, а также нулевых значений:

1. <span style="color: violet">__signed char__</span>
2. <span style="color: violet">__short int__</span>
3. <span style="color: violet">__int__</span>
4. <span style="color: violet">__long int__</span>
5. <span style="color: violet">__long long int__</span>

Для каждого знакового типа есть <span style="color:orange">_аналог_</span> - безнаковый тип, т.е.:

1. <span style="color: violet">__unsigned char__</span>
2. <span style="color: violet">__unsigned short int__</span>
3. <span style="color: violet">__unsigned int__</span>
4. <span style="color: violet">__unsigned long int__</span>
5. <span style="color: violet">__unsigned long long int__</span>

>При объявлении, если объявляется не int или signed char, <span style="color:orange">_можно опустить int_</span>.

С помощью беззнаковых типов можно представлять только <span style="color:orange">_положительные и нулевые значения_</span>.

В целом, целочисленные типы используются для обозначения целых чисел. Размер этих типов может отличаться на разных платформах, но <span style="color:orange">_диапазон значений гарантирован_</span>.

> Стандарт гарантирует, что диапазон каждого более широкого типа покрывает диапазон предыдущего

Конкретный размер разных целочисленных типов можно определить по минимально и максимально допустимым значениям, указанным в заголовочном файле <span style="color:orange">_limits.h_</span>.

> Тип int обычно имеет естественный размер, вытекающий из архитектуры среды выполнения - в 16-битной архитектуре это 16 бит, а в 32-битной — 32 бита. Выделить целочисленные значения нужного размера можно при помощи более точных int-типов (у них точно задана <span style="color:orange">_битность_</span>), указаных в файлах <span style="color:orange">_stdint.h_</span> и <span style="color:orange">_inttypes.h_</span>, например, <span style="color:orange">_uint32_t_</span> или самые широкие <span style="color:orange">_uintmax_t_</span> и <span style="color:orange">_intmax_t_</span>.

Как правильно вести расчёты, в т.ч. с целыми числами, как хранятся числа в памяти - все в [описании арифметических типов](#арифметические-типы)

##### <span style="background-color:green">ПЕРЕЧИСЛЯЕМЫЕ ТИПЫ</span>
<span style="color: violet">__Перечисления__</span> - позволяет определить тип, который назначает <span style="color:orange">_имена (перечислители)_</span> целым значениям, когда требуется перечисляемый набор постоянных значений.

Если у первого перечислителя в перечислении не будет указано значение, он автоматически примет значение <span style="color:orange">_0_</span>. Каждая следующая константа без оператора присваивания =, будет принимать значение на единицу больше предыдущего. Каждому перечислителю можно задать значение, при чём <span style="color:orange">_значения не обязательно должны быть уникальными_</span>.

> Значения констант в перечислении должны быть совместимы с типом int, хотя в действительности их тип зависит от реализации. Например, <span style="color:orange">_Visual C++ использует signed int, а GCC — unsigned int_</span>.

##### <span style="background-color:green">ТИПЫ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

1. <span style="color: violet">__float__</span>
2. <span style="color: violet">__double__</span>
3. <span style="color: violet">__long double__</span>

Арифметические операции с плавающей запятой похожи на операции с числами с плавающей запятой и зачастую служат для них моделью. Стандарт языка С допускает разные варианты представлений чисел с плавающей запятой, и в большинстве систем реализован соответствующий стандарт IEEE (IEEE 754–2008). Выбор того или иного варианта зависит от реализации.

#### <span style="background-color:green">ТИП VOID</span>

<span style="color: violet">__void__</span> - не может принимать значения, с его помощью можно сигнализировать о том, что ваша функция не возвращает значение или не принимает аргументов

Есть производный тип <span style="color:orange">_minvoid*_</span>, который означает, что указатель может ссылаться на любой объект.

### <span style="background-color:green">ФУНКЦИОНАЛЬНЫЕ ТИПЫ</span>

Являются <span style="color:orange">_производными_</span>, т.е. основаны на типе возвращаемого значения, а также на количестве и типах параметров функции, при чём тип возвращаемого значения не может быть массивом.

### <span style="background-color:green">ПРОИЗВОДНЫЕ ТИПЫ</span>

<span style="color: violet">__Производные типы__</span> - это типы, основанные на других типах - указатели, массивы, определения типов, структуры, объединения.

#### <span style="background-color:green">УКАЗАТЕЛИ</span>

<span style="color:violet">__Указатель__</span> - переменная, которая хранит <span style="color:orange">_адрес памяти_</span> другой переменной или функции. <span style="color:violet"> __Адрес__</span> - область памяти, в которой хранятся объекты или функции.

<span style="color:violet">__Ссылочный тип__</span> - тип указателя, определяемый типом данных, на которые он ссылается.

<span style="background-color:red; color: black">__АЛАРМ!__</span> <span style="color:orange">_Объектные указатели_</span> (то есть указатели на объект) отличаются от <span style="color:orange">_функциональных указателей_</span> (то есть указатели на функцию) => их нельзя использовать как взаимозаменямые.

```c
void swap(int* a, int* b) {
    int temp = *a;

    *a = *b;
    *b = temp;
}
```
> int temp = *a; - унарная операция * - <span style="color:violet">__операция разыменовывания__</span>, т.е. получение значения по адресу памяти, куда указывает указатель а. Если операнд указывает на функцию, то результатом использования * будет ее обозначение (designator), а если на объект, то результатом будет значение этого объекта.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если указатель не ссылается на действительный объект или функцию, то может произойти что-то плохое (например, прога крашнется)

```c
swap(&a, &b);
```
> унарная операция & - операция взятия адреса

```c
#include <stdlib.h>
#include <stdio.h>

void swap(int*, int*);

int main(void) {
    int a = 15, b = 71;
    printf("a = %d, b = %d до вызова функции\n", a, b);

    swap(&a, &b);
    printf("a = %d, b = %d после вызова функции\n", a, b);

    return EXIT_SUCCESS;
}

void swap(int* a, int* b) { //параметры, при вызове функции, будут содержать копии аргументов, т.е. переданных адресов - имитация передачи аргументов по ссылке
    int temp = *a;

    *a = *b;
    *b = temp;
}
```

> Считается <span style="color:orange">_производным типом или ссылочным типом_</span> (см. типы - это выше) - потому что указатель - производный тип от типа функции или объекта, на которые ссылается

> Также обратите внимание на указатель на void (void*). Он может хранить адрес любого объекта, но не может быть разыменован без приведения к конкретному типу.

#### <span style="background-color:green">МАССИВЫ</span>

<span style="color: violet">__Массив__</span> — это последовательность объектов одного и того же типа, выделенных один за другим. Тип массива характеризуется <span style="color:orange">_типом и количеством его элементов_</span>.

<span style="color:orange">_Квадратные скобки ([]) используются для идентификации элемента массива_</span>.

Идентификатор массива - это, по сути, <span style="color:orange">_укзатаель на первый элемент массива_</span>.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> массив и указатель — не одно и то же, но в контексте использования массива в выражениях он преобразуется в указатель.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Индексация в массиве с 0.

> Взять адрес i-го элемента массива можно с помощью операции +. 
```c
int main(void) {
    char str[11];

    char* array_member = str + 5;
}
``` 
> В силу того, что элементы массива находятся в памяти ровно друг за другом, то проблем со смещением указателя не возникнет. Кстати, операция str + 5 эквивалентна операции &str[5]. P.S. NAGGER, ответь: почему так?

> Двумерные массивы (к слову, массивы могут быть <span style="color:orange">_многомерными_</span>) называют <span style="color:orange">_матрицами_</span>. По сути, <span style="color: violet">__многомерный массив__</span> - это <span style="color:orange">_массив массивов_</span>.

```c
void func(int arr[5]);

int main(void) {
    unsigned int i = 0;
    unsigned int j = 0;
    int arr[3][5];
    func(arr[i]);
}

//в самой функции int arr[5] - превращается в указатель на первый элемент массива
void func(int arr[5]) {
    int x = arr[j];

    return 0;
}
```

При использовании выражения arr[i] (эквивалентного *(arr+i)), происходит следующее:

1. Массив arr преобразуется в <span style="color:orange">_указатель_</span> на массив из пяти элементов типа int, начиная с arr[i], т.е. происходит превращение в указатель на первый элемент массива arr[i].

2. Индекс i подстраивается под тип arr за счет <span style="color:orange">_умножения_</span> на размер одного массива из пяти объектов int, т.е. мы получаем адрес первого элемента очередного массива (1 * 5 - так вычисляется адрес arr[1]).

3. Результаты первых двух шагов <span style="color:orange">_складываются_</span>.

4. Происходит <span style="color:orange">_косвенное обращение к результату_</span>, чтобы получить массив из пяти элементов типа int.

#### <span style="background-color:green">СТРУКТУРЫ</span>

<span style="color: violet">__Структура__</span> - объект, содержащий последовательно выделенные объекты-члены.

Каждый объект обладает собственным именем, а тип может быть разный.

> Чем-то похож на тип данных <span style="color:orange">_record ("запись")_</span> из других ЯП (например, Java)

```c
struct NAGGER {
    wchar_t name[255];
    wchar_t catchphrase[255];
    double money;
};
```
> У структуры NAGGER 3 <span style="color:orange">_объекта-члена_</span>. Какие?

Позволяют объявлять коллекции связанныъ между собой объектов. Могут использваться для представления даты, данных клиентов и т.п.

Полезны для представления и группирования похожих объектов, часто передающихся вместе в виде аргументов функций - тогда объекты не приходится передавать по отдельности.

Для доступа к полям используется <span style="color:orange">_операция доступа (.)_</span>, а если работать с указателем на структуру - <span style="color:orange">_операция доступа (->)_</span>

#### <span style="background-color:green">ОБЪЕДИНЕНИЯ</span>

Чем-то похожи на структуры, но есть одно большая разница - члены объединения используют одну и ту же память. Обращение то же, как и у структур - или (.), или (->)

> В один момент времени объединение может содержать объект одного типа, а в другой момент времени — объект другого типа, но <span style="color:orange">_никогда не может содержать оба объекта сразу_</span>, т.е. span style="color:orange">_объекты накладываются друг на друга_</span>. Если изменить значение одного члена, может измениться значение второго. Смотри jokes_with_unions.с для понимания

Используется в основном для <span style="color:orange">_экономии памяти_</span>, но объединения полезны когда:

1. нужно экономить память (несколько вариантов данных, но используется один)

2. нужно работать с разными представлениями одних данных

3. реализуются варианты (variant) или полиморфизм в C (об этом сильно позже)

При объявлении переменной объединения можно инициализировать <span style="color:orange">_только значения(-е) первого поля_</span>, точнее в C99 появилась возможность инициализировать конкретный член объединения с помощью designated initializer, например:
union ascii code = { .letter = 'A' };
или
union ascii code = { .digit = 65 };

Но если использовать инициализатор без указания члена, то он будет применен к первому члену.

> Для объединений всегда нужна константа или член-значение в каждом объекте объединения, который бы указывал, какой объект был записан последним. 

### <span style="background-color:green">ОПРЕДЕЛЕНИЯ ТИПОВ</span>

<span style="color: violet">__typedef__</span> - используется для создания псевдонима для <span style="color:orange">_существующего_</span> типа. 

<span style="background-color:red; color: black">__АЛАРМ!__</span> НОВОГО ТИПА typedef <span style="color:orange">_НЕ СОЗДАЁТ_</span>.

> Идентификаторы, находящиеся в стандартных заголовочных файлах и заканчивающиеся на <span style="color:orange">__t_</span>, являются <span style="color:orange">_определениями типов_</span> (псевдонимами для существующих типов). Программистам не нужно соблюдать это соглашение - стандарт C резервирует все такие идентификатора, соответствующие шаблонам <span style="color:orange">_int[0-9a-z_]*_t_</span> и <span style="color:orange">_uint[0-9a-z_]*_t_</span>, а спецификация <span style="color:orange">_POSIX (Portable Operating System Interface — переносимый интерфейс операционных систем)_</span> резервирует все идентификаторы, которые заканчиваются на <span style="color:orange">__t_</span>. В случае определения идентификатора с таким именем может возникнуть конфликт с именами, которые используются реализацией. Это, в свою очередь, может спровоцировать проблемы, которые будет сложно диагностировать.

### <span style="background-color:green">ТЕГИ</span>

<span style="color: violet">__Теги__</span> — это специальный механизм именования структур, объединений и перечислений. Это то слово, которое идет после ключевого <span style="color:orange">_struct_</span>

Сам по себе <span style="color:orange">_тег не является именем типа_</span>, и его нельзя использовать для объявления переменных, т.е. когда происходит объявление объекта структуры, то тип объекта будет иметь вид <span style="color:orange">_struct тег_структуры идентификатор_</span>, без <span style="color:orange">_идентификатора_</span> нельзя объявлять переменную, <span style="color:orange">_тег_структуры идентификатор_</span> - тоже не получится объявить переменную

Названия объединений и перечислений — тоже теги, а не типы. Это значит, их недостаточно для объявления переменной. 
```c
enum day { sun, mon, tue, wed, thu, fri, sat };
day today;         // ошибка
enum day tomorrow; // правильно
```

Теги структур, объединений и перечислений определяются в <span style="color:orange">_собственном пространстве имен_</span>, отдельно от обычных идентификаторов. Благодаря этому программа на C может иметь в одной области видимости тег и другой идентификатор, который выглядит точно так же:
```c
enum status { ok, fail }; // перечисление
enum status status(void); // функция

//можно даже так, не совсем корректно, но ЯП позволяет
struct s s;
```
При помощи typedef можно объявить псевдоним для структуры (как в файле jokes_with_structs.c), и тогда именование объектов структур будет чуть проще выглядеть.

Если в структуре есть ссылка на саму себя, то без тега никак.
```c
struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
};
```
Но можно сделать иначе:
```c
typedef struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
}tnode;
```
Большинство программистов на C используют для тегов и typedef разные имена, хотя можно обойтись и общим именем. Можно определить данный тип перед структурой; это позволит объявить члены left и right, которые ссылаются на другие объекты типа tnode:
```c
typedef struct tnode tnode;

struct tnode {
  int count;
  tnode *left
  tnode *right;
} tnode;
```

### <span style="background-color:green">КВАЛИФИКАТОРЫ ТИПОВ</span>

Все типы по умолчанию <span style="color:orange">_неквалифицированные_</span>. Это можно исправить при помощи ключевых <span style="color:orange">_слов-квалификаторов_</span>, таких как <span style="color:orange">_const_</span>, <span style="color:orange">_volatile_</span> и <span style="color:orange">_restrict_</span>.

Каждый квалификатор влияет на поведение кода при обращении к объектам квалифицированного типа.

Квалифицированная и неквалифицированная версии типа являются взаимозаменяемыми в случае использования в качестве аргументов функций, возвращаемых значений и членов объединений.

> Квалификатор типа <span style="color:orange">__Atomic_</span>, появившийся в C11, предоставляет поддержку конкурентного выполнения.

#### <span style="background-color:green">КВАЛИФИКАТОР CONST</span>

Объекты с этим квалификатором <span style="color:orange">_не подлежат изменению_</span> - это значит, что компилятор размещает их в памяти, доступной только для чтения, и любая попытка их перезаписи приведет к ошибке выполнения.

> Можно попытаться схитрить, изменив const-значение при помощи указателей, но это приведет к неопределённому поведению

```c
const int i = 1; // объект неконстантного типа
int *ip = (int *)&i;
*ip = 2;  // неопределенное поведение
```

> Даже во время приведения типов C не позволяет избавиться от const, если он был у исходного объекта.

Но, все меняется при работе с константными указателями:
1. const в указателях - это "обещание" не менять данные через этот указатель
2. приведение const T* к T* - обход системы типов
3. работает только если исходный объект не был объявлен как const
4. неопределенное поведение если исходный объект действительно константный
5. лучшая практика: избегать таких приведений - они нарушают контракт кода

> Пример

```c
int i = 12;
const int j = 12;
const int *ip = &i;
const int *jp = &j;
*(int *)ip = 42; // правильно
*(int *)jp = 42; // неопределенное поведение
```

#### <span style="background-color:green">КВАЛИФИКАТОР VOLATILE</span>

##### <span style="background-color:green">Основная концепция</span>

volatile сообщает компилятору, что значение переменной может измениться способами, не предсказуемыми программой. Компилятор не должен оптимизировать доступ к таким переменным.

##### <span style="background-color:green">КЛЮЧЕВЫЕ СЛУЧАИ ИСПОЛЬЗОВАНИЯ</span>

1. Аппаратные регистры (Memory-mapped I/O)
2. Устройства, меняющиеся независимо от программы
3. Обработчики сигналов

const + volatile используется для устройств "только для чтения", которые меняются самостоятельно:

Не применять для:

1. многопоточности (в т.ч. для синхронизаии между потоками)
2. не гарантирует порядок операций

#### <span style="background-color:green">КВАЛИФИКАТОР RESTRICT</span>

restrict-квалифицированный указатель используется для поддержки оптимизации. Объекты, к которым обращаются косвенно через указатели, зачастую не удается оптимизировать должным образом из-за того, что на один и тот же объект теоретически могут ссылаться сразу несколько указателей. Это может затруднить оптимизацию, поскольку компилятор не знает, может ли модификация одного объекта привести к частичному изменению другого, который с виду никак с ним не связан.

Использование указателей с квалификатором restrict делает код более эффективным, но, чтобы избежать неопределенного поведения, программист обязан обеспечить, чтобы участки памяти, на которые они ссылаются, не пересекались.

Если говорить проще, этот квалификатор обозначает, что объявляемый указатель адресует область памяти, на которую не ссылается никакой другой указатель. 

## <span style="background-color:green">ФУНКЦИИ</span>

<span style="color: violet">__Функция__</span> - это именованный блок кода, который выполняет одну конкретную задачу. Может быть вызвана много раз.

У функции могут быть описаны <span style="color:violet">__параметры__</span> - объекты, которые объявляются вместе с функцией и получают значения при входе в нее, а те самые значения - есть <span style="color:violet">__аргументы__</span>. В языке C передача <span style="color:orange">__аргументов__</span> при вызове происходит <span style="color:orange">_по значению_</span>; то есть когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. Изменение значений параметров в функции не влияет на значения в вызывающем коде, поскольку это разные объекты.

<span style="color: violet">__Прототип (объявление) функции__</span> - сочетание типа возвращаемого значения, имени и параметров функции. Он сообщает компилятору о количестве и типах параметров, которые она принимает. С помощью этой информации компиляторы следят за тем, чтобы в <span style="color:orange">_определении функции_</span> и в любых ее вызовах использовалось корректное количество параметров с подходящими типами.

> <span style="color: violet">__Определение функции__</span> - реализация функции

При объявлении функции нужно указать ее <span style="color:orange">_имя и тип значения, которое она возвращает_</span>. Если объявление совмещено с определением и предусматривает список параметров, в объявлении каждого параметра необходимо указать идентификатор. Исключение составляет случай, когда имеется только один параметр типа <span style="color:orange">_void_</span>, который не нуждается в идентификаторе.

```c
//int - это спецификатор возвращаемого значения, max(int a,int b) - объявление функции, а {return a > b ? a : b;} - ее тело, т.е. определение
int max(int a, int b)
{ 
    return a > b ? a : b; 
}
```

Если в объявлении функции после типа указан знак *, это значит, что параметр является <span style="color:orange">_указателем_</span> на объект или функцию заданного типа.

Не объекты, но имеют тип, характеризуемый возращаемым значением и числом/типами параметров. (см. функциональные типы)

```c
//1
int f(void);
//2
int *fip();
//3
void g(int i, int j);
//4
void h(int, int);
```
<span style="background-color:red; color: black">__АЛАРМ!__</span> Задать имя параметра не получится, если есть макрос с таким же именем (пример 3 - если бы существовали макросы с именами i или j, то прога не скомпилируется). 

> Но всё же задавать имя параметрам рекомендуется - это способствует написанию <span style="color:orange">_самодокументируемого кода_</span>

<span style="background-color:red; color: black">__АЛАРМ!__</span> В C никогда не следует объявлять функции с пустым списком параметров. Причины:

1. устаревшая возможность языка => может исчезнуть
2. код может быть перенесён в c++, от чего поведение его может измениться (см. далее почему)

> Если переместить функцию fip в c++ (пример 2), то она будет возвращать целочисленный указатель и не будет принимать значений, но при этом в c, даже при одинаковом типе возвращаемого значения - она может принимать любое количество аргументов любого типа.

## <span style="background-color:green">ОБЛАСТИ ВИДИМОСТИ</span>
<span style="color:violet">__Область видимости__</span> - 1) блок кода, в котором возможно обращение к идентификатору. В языке C область видимости может охватывать <span style="color:orange">_файл_</span>, <span style="color:orange">_блок кода_</span>, <span style="color:orange">_функцию_</span>, <span style="color:orange">_прототип(объявление) функции_</span>. 2) регион программы, в котором идентификатор может быть использован

Область видимости определяется местом, где он объявлен:
1. <span style="color:violet">__На уровне файла__</span>. Это значит, что идентификатор доступен на уровне всего файла, где объявлен, а также во всех других файлах, где используется файл объявления. Например, в файле source.h, в самом начале файле, после объявления заголовочного файла, мы определили макрос <span style="color:orange">_nagger_</span>, и если мы подключим этот файл в source_code.c, то мы сможем этим макросом пользоваться в .c файле.
```c
//source.h
#define nagger "NAGGER" 

//source_code.h
#include <source.h>
int main() {
    char* naggers_name = nagger;
}
```

> Макрос не имеет области видмости в общем понимании этого слова, как идентификатор, поэтому вот еще пример

```c
//source.h
void swap(int*, int*);

//source_code.h
#include <source.h>
int main() {
    int a = 0;
    int b = 1;
    swap(&a, &b);
}
```
2. <span style="color:violet">__Блочная область видимости__</span>. Объявленный идентификатор доступн только в том блоке, в котором объявлен. 
```c
int main() {
    int a = 1;
    {
        int temp = 2;
    }

    int b = temp + a; //АЛАРМ!!!!!!!! ОШИБКА!!!!!!!!!
}
``` 
3. <span style="color:violet">__Область видимости в прототипе функции__</span>. Параметры в прототипе видны только в этом прототипе.
```c
int swap(int a, int b);

int main() {
    a = 0; //АЛАРМ!!!!!!!!!!!ОШИБКА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
```
4. <span style="color:violet">__Область видимости функции__</span>. Только для меток. <span style="color:orange">_Метка_</span>, объявленная в функции, видна в любом месте этой функции.
> Про метки будет инфа чуть позже<br>
> В функции, параметры этой функции и локальные переменные имеют блочную область видимости (блоком является тело функции)

Области видимости могут быть <span style="color:orange">_вложенными_</span> и находиться как внутри, так снаружи других блоков.

При объявлении одинаковых идентификаторов в <span style="color:orange">_наружней_</span> и <span style="color:orange">_внутренней_</span> областях видимости, объявленный во внутренней будет перекрвать наружнюю версию.

> Пример

```c
int j; // начинается область видимости уровня файла j

void f(int i) {// начинается блочная область видимости i
    int j = 1; // начинается блочная область видимости j
                  // перекрывает j в области видимости уровня файла
    i++;// i ссылается на параметр функции
    for (int i = 0; i < 2; i++) { // начинается блочная область видимости i
        // внутри цикла
        int j = 2;// начинается блочная область видимости j
                     // перекрывает внешнюю j
        printf("%d\n", j); // внутренняя j в области видимости, выводит 2
    }// заканчивается блочная область видимости
     // внутренних i и j
    printf("%d\n", j);   // внешняя j в области видимости, выводит 1
}// заканчивается блочная область видимости i и j

void g(int j); // j имеет область видимости уровня прототипа
                    // перекрывает j уровня файла
```

## <span style="background-color:green">СРОК ХРАНЕНИЯ</span>

<span style="color:violet">__Срок хранения__</span> определяет <span style="color:orange">_время жизни_</span> объекта.

Какие есть сроки хранения:

1. <span style="color:violet">__Автоматический__</span>. Время жизни объекта начинается при выполнении блока и заканчивается вместе с выполнением блока. Например, <span style="color:orange">_параметры функции_</span>.
> Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.
2. <span style="color:violet">__Статический__</span>. Таким сроком хранения обладают объекты, объявленный на уровне файла. Время жизни = <span style="color:orange">_время выполнения программы_</span>, а значения инициализируются ещё до запуска программы.
> При помощи модификатора <span style="color:orange">_static_</span> можно задать статический срок хранения даже переменным с <span style="color:orange">_блочной видимостью_</span>. Смотри файл functions_objects_and_types/jokes_with_lifetime.c
> Статические объекты должны <span style="color:orange">_инициализироваться с помощью константного значения, а не переменной_</span> 
```c
int *func(int i) {
  const int j = i;  // правильно
  static int k = j; // ошибка
  return &k;
}
```
> К константным значениям относятся <span style="color:orange">_константы-литералы_</span> (например, 1, 'a' или 0xFF), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.
3. <span style="color:violet">__Потоковый__</span> - используется в <span style="color:orange">_конкурентном программировании_</span>.
> <span style="color:violet">__Конкурентное программирование__</span> - это подход к разработке программного обеспечения, при котором несколько вычислительных процессов выполняются одновременно, чтобы повысить эффективность и производительность систем. 
4. <span style="color:violet">__Выделенный__</span> или <span style="color:violet">__динамический__</span> - задействован в работе с динамически выделяемой памятью

<span style="background-color:red; color: black">__АЛАРМ!__</span> При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.

## <span style="background-color:green">ВЫРАВНИВАНИЕ</span>

<span style="color:violet">__Выравнивание__</span> - это требование типов объектов, ограничивающее допустимые адреса для размещения объектов. Оно определяет количество байтов между смежными адресами, при котором может быть сохранен объект данного типа. Адрес выровненных данных может быть кратен размеру объекта, и процессор может обрабатывать выровненные и невыровненные данные по-разному. 

Любой компьютер выполняет многобайтный доступ к данным по границам <span style="color:orange">_машинного слова_</span>(выровненный доступ). Однако:

1. Некоторые системы могут также обращаться к невыровненным данным с потерей производительности (либо с ошибками в результате)

2. Другие системы вообще не поддерживают невыровненный доступ

> <span style="color:violet">__Машинное слово__</span> - естественная единица фиксированного размера для измерения данных, с которыми работают инструкции или аппаратные механизмы процессора.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Требования к выравниванию могут зависеть от размера машинного слова в конкретном процессоре (обычно это 16, 32 или 64 бита).

В целом, при программировании на C не стоит греть голову о выравнивании, но иногда бывают ситуации, когда решения компилятора о выравнивании памяти приходится переопределять - например, для выравнивания данных на границах строк кэша (адреса должны быть кратны степеням 2). Для этого можно пойти двумя способами:

1. команды компоновки;

2. выделение дополнительной памяти с помощью <span style="color:orange">_malloc_</span> с последующим округлением пользовательского адреса вверх;

3. другие нестандартные средства.

Также гарантируется, что память выделенная при помощи <span style="color:orange">_malloc_</span>, будет достаточно выравнена для всех стандартных типов (включая массивы и структуры). 

> Например, есть структура:
```c
struct nagger {
    char[20] name;
    double money;
}
```
> char[20] потребует 20 байт для хранения данных, bouble - ещё 8, итого - 28 байт на объект структуры. После выравнивания, в некоторых системах для объекта будет выделено 32 байта, а в каких-то 64 (будет округлено до степеней 2) - добавятся <span style="color:orange">_отступы_</span> либо в конец памяти, выделенной для объекта, либо меджу байтами данных <span style="color:orange">_name_</span> и <span style="color:orange">_money_</span> - чтобы поле money было выровнено по адресу, кратному 8, и тогда размер структуры составит 32 байта.

В c11 появился простой способ указания выравнивания, совместимый с будущими версиями стандарта:

1. Выравнивание представляется как неотрицательное целое число типа <span style="color:orange">_size_t_</span>.
2. Корректное выравнивание должно быть степенью двойки.

Также в c11 появился спецификатор выравнивания <span style="color:orange">__Alignas_</span>:

1. Позволяет указать, что переменная должна быть выровнена определенным образом.
> Пример в functions_objects_and_types/jokes_with_alignments.c

Строгость выравнивания:

1. Способы выравнивания упорядочены от слабых к строгим.

2. Чем строже выравнивание, тем больше его значение (т.е. больше байт).

3. Адрес, удовлетворяющий строгому выравниванию, автоматически удовлетворяет и более слабым (меньшим) выравниваниям.

# <span style="background-color:green">3 АРИФМЕТИЧЕСКИЕ ТИПЫ</span>

Включают целые числа + числа с плавающей точкой

## <span style="background-color:green">3.1 ЦЕЛЫЕ ЧИСЛА</span>

> Мы о них уже говороли, когда разбирали [целочисленные типы](#целочисленные-типы). Вкратце, это <span style="color:orange">_int_</span> и его подтипы с модификаторами (<span style="color:orange">_long_</span>, <span style="color:orange">_short_</span>, <span style="color:orange">_insigned_</span>)

<span style="color:orange">_Значение_</span> целочисленного объекта является обычным математическим числом и <span style="color:orange">_представлено в виде битов в выделенной для объекта памяти_</span>, которые кодируют это значение.

Объявяляются целые переменные следующим образом:

1. всегда имеет знак, если не объявлен как <span style="color:orange">_unsigned_</span> (<span style="color:orange">_char_</span> - исключение, может иметь знак, а может не иметь - зависит от реализации)
2. как и было указано в [целочисленых типах](#целочисленные-типы), можно опустить <span style="color:orange">_int_</span>, если это не единственное ключевое слово
3. то же и с signed-типами - <span style="color:orange">_signed_</span> при объявлении можно опустить, т.к. все целочисленные типы по умолчанию <span style="color:orange">_знаковые_</span> (исключение, опять же, <span style="color:orange">_char_</span> - signed char и просто char без него не отличить)

### <span style="background-color:green">3.1.1 ЗАПОЛНЕНИЕ И ТОЧНОСТЬ</span>

<span style="color: violet">__Заполнение__</span> - неиспользуемые биты, которые могут содержаться в всех целых типах (кроме <span style="color:orange">_char_</span>, <span style="color:orange">_signed char_</span> и <span style="color:orange">_unsigned char_</span>). Позволяют <span style="color:orange">_реализации_</span> обходить ошибки или особенности аппаратной платформы (например, пропуск знакового бита между несколькими машинными словами), а также поддерживать целевую архитектуру.

<span style="color: violet">__Ширина__</span> - количество битов, используемых для представления значения, включая <span style="color:orange">_знаковывй бит_</span> и не включая <span style="color:orange">_заполнение_</span>. Обозначается буквой <span style="color:orange">_N_</span>.

<span style="color: violet">__Точность__</span>  - количество битов, которые используются для представления значения, не включая <span style="color:orange">_знаковый бит_</span> и <span style="color:orange">_заполнение_</span>.

### <span style="background-color:green">3.1.2 ЗАГОЛОВОЧНЫЙ ФАЙЛ limits.h</span>

Предоставляет минимальные и максимальные значения целочисленных типов.

<span style="color: violet">__Допустимое значение__</span> - значение, которое можно представить с помощью того количества битов, которое доступно объекту конкретного типа.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если компилятор встретит недопустимое значение, будет два варианта: либо компилятор выкинет сообщение с предупреждением, либо запишет значение, преобразовав его в представимое (заведомо некорректное).

Разработчики компиляторов предоставляют для своих реализаций подходящие минимальные и максимальные значения, а также корректную ширину.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Написание переносимого кода требует использования этих констант вместо целочисленных литералов наподобие +2147483647, которые представляют специфичные для конкретной реализации ограничения и могут измениться при переходе на другую реализацию.

Требования стандарта C к размерам целых чисел:

1. область хранения любого типа данных должн иметь объём, кратный размеру <span style="color:orange">_unsigned char_</span> (возможно, включая заполнение)
2. каждый целочисленный тип должен поддерживать минимальный диапазон значений, применимый в любой реализации
3. меньший тип не может быть шире большего
   
### <span style="background-color:green">3.1.3 БЕЗЗНАКОВЫЕ ЦЕЛЫЕ</span>

Диапазон начинается с нуля и заканчивается числами, большими, чем верхние границы соответствующих знаковых типов (см. ariphmetic_types/jokes_with_ariphmetic_types.c), поэтому часто применяются для представления <span style="color:orange">_больших неотрицательных чисел_</span>.

#### <span style="background-color:green">3.1.3.1 ПРЕДСТАВЛЕНИЕ</span>
Значения представляются <span style="color:orange">_без смещения_</span>, в сугубо <span style="color:orange">_двоичной системе_</span>: самый младший бит имеет вес 2 ^ 0, следующий за ним — 2 ^ 1 и т.д. <span style="color: violet">__Значение двоичного числа__</span> — это сумма весов всех битов.

> Пример представления значения в разных системах счисления (без заполнения)

|десятичное|двоичное|шестнадцатиричное|
|-------------|-----------|-----------------------|
|0|00000000|0x00|
|1|00000001|0x01|
|17|00010001|0x11|
|255|11111111|0xFF|

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Преобразования из 2 системы счисления в 10 можно представить в виде <span style="color:orange">_таблицы степеней 2_</span>:

|Степень двойки|7|6|5|4|3|2|1|0|
|------------------|-|-|-|-|-|-|-|-|
|Значение*         |1 |1| 1|1| 1|1|1|1|

> Что получается:
> 11111111 = 1x(2 ^ 0) + 1x(2 ^ 1) + 1x(2 ^ 2) + 1x(2 ^ 3) + 1x(2 ^ 4) + 1x(2 ^ 5) + 1x(2 ^ 6) + 1x(2 ^ 7) = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 = 255  

> _*_ - 0 или 1 - грубо говоря, влезет ли эта степень двойки в представление или нет

Точность у беззнаковых обычно <span style="color:orange">_выше_</span>, так как знаковый бит используется <span style="color:orange">_не для представления знака_</span> (что, беззнаковым, собственно не надо), <span style="color:orange">_а для представления значения_</span>.

Диапазон: от <span style="color:orange">_0_</span> до <span style="color:orange">_2^N - 1_</span>, где N - <span style="color:orange">_ширина_</span> (см. [заполнение и точность](#заполнение-и-точность)). <span style="color:orange">_limits.h -> UINT_MAX_</span> определяют верхнюю границу для данного типа в конкретной реализации

> В большей части x86 архитектур используются 32-битные целые (без заполнения), а значит unsigned int имеет диапазон от 0 до 2^N - 1, т.е. от 0 до 4 294 967 295

Ожидаемые значения для x86 архитектур в таблице ниже

|Константа|Максимальная величина|Значение в x86|Тип|
|-----------|-----------------------------|------------------|-----|
|UCHAR_MAX|2^8 - 1 = 255|2^8 - 1 = 255|unsigned char|
|USHRT_MAX|2^16 - 1 = 65 535|2^16 - 1 = 65 535|unsigned short int|
|UINT_MAX|2^16 - 1 = 65 535|4 294 967 295|unsigned int|
|ULONG_MAX|2^32 - 1 = 4 294 967 295|2^32 - 1 = 4 294 967 295|unsigned long int|
|ULLONG_MAX|2^64 - 1 = 18 446 744 073 709 551 615|2^64 - 1 = 18 446 744 073 709 551 615|unsigned long long int|

#### <span style="background-color:green">3.1.3.2 ЦИКЛИЧЕСКИЙ ПЕРЕНОС</span>

<span style="color: violet">__Циклический перенос (wraparound)__</span> - определённое поведение (в языке C), проявляющееся тогда, когда при выполнении арифметической операции над беззнаковыми результат оказывается либо <span style="color:orange">_слишком мал_</span> (< 0), либо <span style="color:orange">_слишком велик_</span> (> 2 ^ N - 1), чтобы его можно было представить как беззнаковое. В таком случае, полученное значение <span style="color:orange">_делится с остатком_</span> на  N и остаток сохраняется в объект.

> Не всегда является маркером ошибок - например, в некоторых алгоритмах шифрования циклический перенос используется намеренно. Но если проводятся расчёты над беззнаковыми числами, и был выполнен перенос, то в коде ошибка.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Ввиду циклического переноса беззнаковое целочисленное выражение никогда <span style="color:orange">_не может быть меньше 0 и больше 2^N - 1_</span>.

```c
extern unsigned int ui, sum;
if (sum + ui > UINT_MAX)
  too_big();
else
  sum = sum + ui;
```
> Данная проверка некорректна, т.к. значение не может быть больше UINT_MAX в приниципе. Лучше переписать так:

```c
if (ui > UINT_MAX - sum)
  too_big();
else
  sum = sum + ui;
```
>Можно придумать аналогичные проверки для 0

<span style="background-color:red; color: black">__АЛАРМ!__</span> Ширина, используемая при переносе, зависит от реализации.

### <span style="background-color:green">3.1.4 ЗНАКОВЫЕ ЦЕЛЫЕ</span>

Используются для представления отрицательных, нулевых и положительных значений. Диапазон значений зависит, от того, какая у данного типа <span style="color:orange">_ширина_</span> в используемой системе.

Представление в памяти более сложное по сравнению с беззнаковыми. Есть три варианта предсталения:

1. <span style="color:violet">__прямой код__</span> - старший разряд обозначает <span style="color:orange">_знак_</span>, а остальные - <span style="color:orange">_величину значения_</span> в двоичной системе
2. <span style="color:violet">__обратный код__</span> - разряд со знаком имеет вес <span style="color:orange">_-(2^(N-1) - 1)_</span>, а остальные имеют тот же вес, что и в беззнаковом типе. Используется для представления <span style="color:orange">_отрицательных чисел_</span>, в том числе, как основа для дополнительного кода
3. <span style="color:violet">__дополнительный код__</span> - знаковый бит имеет вес <span style="color:orange">_-(2^(N-1))_</span>, а остальные имеют тот же вес, что и в беззнаковом типе. Для представления  <span style="color:orange">_отрицательного числа_</span>высчитывается его значение в  <span style="color:orange">_обратном коде_</span> и к этому значению прибавляется 1.

<span style="background-color:red; color: black">__АЛАРМ!__</span> В обратном коде биты, кодирующие само значение заполняются <span style="color:orange">_обратные величины_</span>, т.е. если -1 в прямом коде это 10000001, то в обратном коде это значение будет иметь вид 11111110. А в <span style="color:orange">_дополнительном коде_</span> необходимо сложить значения <span style="color:orange">_обратного кода_</span> и <span style="color:orange">_1_</span>, и, таким образом, для -1 значение в дополнительном коде будет равно 11111111.

<span style="background-color:red; color: black">__АЛАРМ! v2__</span> Положительные знаковые числа <span style="color:orange">_не переводятся_</span> в обратный и дополнительный код

> Представление <span style="color:orange">_определяется реализацией_</span>, самому его выбрать нельзя. Используются все три, но наиболее используемый - <span style="color:orange">_дополнительный код_</span>. Комитет по стандартам C оставил только дополнительный код во всех C2x версиях

Диапазон знаковых чисел: от <span style="color:orange">_-(2 ^ (N - 1))_</span> до <span style="color:orange">_2 ^ (N - 1) - 1_</span>

Таблица максимальных и минимальных значений знаковых типов (из <span style="color:orange">_limits.h_</span>)

|Константа|Значение (минимальное)|Значение в x86|Тип|
|------------|----------|------------------|-----|
|SCHAR_MIN|–127 = – (2 ^ (8 - 1) – 1)|–128|signed char|
|SCHAR_MAX|+127 = 2 ^ (8 - 1) – 1|То же|signed char|
|SHRT_MIN|–32 767 = –(2 ^ (16  - 1) – 1)|–32 768|short int|
|SHRT_MAX|+32 767 = 2 ^ (16  - 1) – 1|То же|short int|
|INT_MIN|–32 767 = –(2 ^ (16  - 1) – 1)|–2 147 483 648|int|
|INT_MAX|+32 767 = 2 ^ (16  - 1) – 1|+2 147 483 647|int|
|LONG_MIN|–2 147 483 647 = –(2 ^ (32 - 1) – 1)|–2 147 483 648|long int|
|LONG_MAX|+2 147 483 647 =  2 ^ (32 - 1) – 1|То же|long int|
|LLONG_MIN|–9 223 372 036 854 775 807 = –(2 ^ (64 - 1) – 1)|–9 223 372 036 854 775 808|long long int|
|LLONG_MAX|+9 223 372 036 854 775 807 = 2 ^ (64 - 1) – 1|То же|long long int|

> <span style="color:violet">__Значение (минимальное)__</span> - это значение, которое стандарт <span style="color:orange">_гарантирует_</span> для типа - оно гарантированно войдет в диапазон значения типа в системах с <span style="color:orange">_разной архитектурой и разными компиляторами (реализациями)_</span>. Также, от степени 2 отнимается 1, чтобы учесть <span style="color:orange">_знаковый бит_</span>.

Представление отрицательных чисел в дополнительном коде состоит из разрядов для хранения знака и самого значения. Разряду со знаком назначается вес –(2N – 1). Чтобы сделать значение отрицательным в дополнительном коде, достаточно инвертировать каждый значащий бит и затем прибавить 1 (с переносом, если это необходимо), как показано в примере:

> 0010 1001 -> 1101 0110 + 1 = 1101 0111

Таблица "восьмибитные значения в дополнительном коде"

|Двоичное|Десятичное|Вес|Константа|
|-----------|--------------|----|------------|
|00000000|0|0||
|00000001|1|2^0||
|01111110|126|2 ^ 6 + 2 ^ 5 + 2 ^ 4 + 2 ^ 3 + 2 ^ 2 + 2 ^ 1||
|01111111|127|2 ^ (N − 1) − 1|SCHAR_MAX|
|10000000|–128|−(2 ^ (N − 1)) + 0|SCHAR_MIN|
|10000001|–127|−(2 ^ (N – 1)) + 2 ^ 0|| 
|11111110|−2|−(2 ^ (N – 1)) + 126||
|11111111|−1|−(2 ^ (N – 1)) + 127||

#### <span style="background-color:green">3.1.4.1 ПЕРЕПОЛНЕНИЕ</span>

Происходит, когда операция со знаковым целым возваращает значение, которое не может быть представлено итоговым типом.

> Пример: макрос (<span style="color:violet">__функциональный макрос__</span> (работает с обобщенными типами), который мы до 9 главы будем обзывать функцией), который будет работать (если будет работать) некорректно для самых отрицательных чисел

```c
#define Abs(i) ((i) < 0 ? -(i) : (i))
#include <limits.h>

...

signed int si = INT_MAX;
signed int abs_si = Abs(si); //неопределённое поведение, т.к. модуль этого числа не представим
printf("%d\n", abs_si);
```

Чаще всего, при переполнении происходит либо <span style="color:orange">_циклический перенос_</span>, либо <span style="color:orange">_прерывание_</span>, либо и то, и то одновременно. <span style="color:violet">__Прерывания__</span> останавливают программу, не давая выполняться следующим операциям. В распространенных архитектурах, таких как x86, сочетаются циклический перенос и прерывание. У данной проблемы нет какого-то единого общепринятого решения.

<span style="color:violet">__Циклический перенос__</span> беззнаковых целых — это определенное поведение. Переполнение целочисленных значений со знаком или возможность такового всегда следует считать дефектом.

> В некоторых системах функция abs представлена так:

```c
int abs(int i) {
  return (i >= 0) ? i : -(unsigned)i; // избегает переполнения
}
```

> Унарный минус определён и для беззнаковых типов: результат вычисляется по модулю UINT_MAX + 1 (т.е. -x == (UINT_MAX + 1) - x). При i = INT_MIN сначала происходит приведение к unsigned (получается большое число без переполнения), затем применяется унарный минус (результат остаётся в пределах беззнакового диапазона). Оператор return неявно преобразует это unsigned обратно в int; поскольку -INT_MIN не представим в int, результат зависит от реализации (implementation-defined). Такой подход избегает неопределённого поведения (переполнения), но не даёт математически верного значения для INT_MIN. Поэтому используется только в некоторых системах и считается компромиссным решением.

### <span style="background-color:green">3.1.5 ЦЕЛОЧИСЛЕННЫЕ КОНСТАНТЫ</span>

<span style="color:violet">__Целочисленные константы__</span> (или <span style="color:violet">__целочисленные литералы__</span>) применяются для добавления в программу конкретных целых чисел. Язык C поддерживает три типа таких констант:

1. десятичные
2. восьмеричные (начинаются с 0, а далее цифры от 0 до 7, например <span style="color:orange">_int number = 007_</span>)
3. цестнадцатиричные (начинаются с 0x, а далее цифры от 0 до 9 и(или) буквы от a(A) до f(F), например <span style="color:orange">_int number = 0x7AB_</span>), которые используются для представления последовательности битов, например, <span style="color:orange">_адрес_</span>

> Принято, что большинство шестнадцатеричных констант записываются как 0xDEADBEEF, поскольку это напоминает типичный дамп памяти в шестнадцатеричном формате.

К объявлению констант можно добавить <span style="color:violet">__суффикс__</span>, чтобы указать тип (без этого, например, десятичная константа получает тип int или иной, которым может быть представлена):

1. U (unsigned)
2. L (signed long)
3. LL (long long)

Также константы можно <span style="color:orange">_объединять_</span>. Пример:

```c
unsigned long long num = 18446744073709551615ULL;
```

С целочислеными константами лучше использовать суффикс, т.к. если константа не имеет подходящего типа, то она может быть (автоматически преобразована)[#автоматическое преобразование], что может привести к неожиданным преобразованиям или лишним предупреждениям компилятора.

## <span style="background-color:green">3.2 ЧИСЛА С ПЛАВЩАЮЩЕЙ ЗАПЯТОЙ</span>

<span style="color:violet">__Числа с плавающей запятой__</span> - самое распространённое представление вещественных значений, использующее экспоненциальную запись для кодирования мантиссы и порядка, т.е. числа в таком виде. Например, десятичное число 123.456 можно представить как 1,23456 × 10^2, а двоичное 0b10100.110 — как 1,0100110 × 2^4

Стандарт C не утверждает какую-то конктретную модель, а отмечает, какая модель <span style="color:orange">_должна поддерживаться_</span>.

### <span style="background-color:green">3.2.1 ТИПЫ С ПЛАВЩАЮЩЕЙ ЗАПЯТОЙ</span>

Язык поддерживает три типа с плавающей запятой:

1. <span style="color:violet">__float__</span> - можно использовать в тех вычислениях, где значение представимо с одинарной точностью. По спецификации <span style="color:orange">_IEC 60559_</span> выделяется один разряд для знака, восемь - для порядка, 23 - для мантиссы
2. <span style="color:violet">__double__</span>. Более точен, чем <span style="color:orange">_float_</span>, выделяется один раряд для знака, 11 - для порядка, 42 - для мантиссы
3. <span style="color:violet">__long double__</span>. Во всех реализациях тип longdouble должен иметь какой-то из следующих форматов: формат числа четверной точности IEC 60559 (или binary128)11; формат двойной точности IEC 60559 (расширенная версия binary64); расширенный формат, несовместимый с IEC 60559; формат двойной точности IEC 60559 (или binary64). Разработчикам компиляторов рекомендуется использовать для типа longdouble формат IEC 60559 binary128 или расширенную версию IEC 60559 binary64. Последняя включает в себя распространенный 80-битный формат IEC 60559.

<span style="background-color:red; color: black">__АЛАРМ!__</span> float < double < long double

#### <span style="background-color:green">3.2.1.1 ЗНАК, ПОРЯДОК И МАНТИССА</span>

<span style="color:violet">__Знаковый бит__</span> - определяет знак (0 - положительное, 1 - отрицательное)

<span style="color:violet">__Порядок__</span> - степень порядкового числа в экспоненциальной записи (например, для -6,022 x 10^23, 23 - это порядок). Чтобы не хранить отдельно знак порядка, инженеры придумали хитрость: к реальному порядку прибавляют <span style="color:violet">__константу__</span> (<span style="color:violet">__смещение__</span>), и в память записывают уже эту сумму. Для float смещение равно 127 (Следовательно, чтобы выразить степень 0, в качестве порядка нужно сохранить 127. Хранимая величина 200 обозначает порядок 200 – 127, или 73. Порядки –127 (когда каждый разряд порядка равен 0) и +128 (когда каждый разряд порядка равен 1) зарезервированы для особых чисел.), для double 1023. 

<span style="color:violet">__Мантисса__</span> - значащие цифры числа.

##### <span style="background-color:green">3.2.1.1.1 IEEE 754</span>

Как это работает? Для понимания, как число представляется в памяти, будем разбирать общий стандарт <span style="color:orange">_IEEE 754_</span>. Есть формула:

-(1)^S * M * 2^E, где S - знак (для всех типов - 1 бит), M - мантисса (для float - 23 бита, для double - 52 бита), E - порядок (для float - 8 бит, для double - 11 бит)

Разберем представление числа на примере типа float (одна клетка - один бит):

|Знак|      Порядок            |                                        Мантисса                                                | 
|-----|-----------------------|--------------------------------------------------------------------------|
|0     |      10000001           |                             01000000000000000000000                            |

Ключевые особенности стандарта IEEE 754:

1. <span style="color:orange">_Денормализованные числа_</span> — позволяют представлять значения, близкие к нулю, ценой снижения точности
2. <span style="color:orange">_Специальные значения_</span> — включают представления для ±∞ и NaN (Not a Number)
3. <span style="color:orange">_Режимы округления_</span> — определяют поведение при невозможности точного представления числа
4. <span style="color:orange">_Исключения_</span> — стандартизированная обработка особых ситуаций, таких как деление на ноль 

Стандарт IEEE 754 определяет несколько форматов представления чисел с плавающей точкой, которые различаются по размеру и, соответственно, диапазону и точности.

|Формат|Размер (биты)|Диапазон (приблизительно)|Десятичных значащих цифр|Типичное применение|
|--------|----------------|----------------------------------|--------------------------------|---------------------------|
binary16 (half)|16|±6.55×10^-8 до ±65504|~3.3|Машинное обучение, графика|
binary32 (single, float)|32|±1.4×10^-45 до ±3.4×10^38|~7|Общее программирование|
binary64 (double)|64|±4.9×10^-324 до ±1.8×10^308|~15-16|Научные расчёты|
binary128 (quad)|128|±6.5×10^-4966 до ±1.2×10^4932|~34|Финансовые вычисления, криптография|

В большинстве языков программирования форматы IEEE 754 представлены соответствующими типами данных:
1. <span style="color:violet">__C/C++__</span>: float (binary32), double (binary64), long double (может быть binary80 или binary128)
2. <span style="color:violet">__Java__</span>: float (binary32), double (binary64)
3. <span style="color:violet">__Python__</span>: все числа с плавающей точкой представлены как binary64
4. <span style="color:violet">__JavaScript__</span>: все числа с плавающей точкой соответствуют binary64
5. <span style="color:violet">__Rust__</span>: f32 (binary32), f64 (binary64) vv

<span style="background-color:red; color: black">__АЛАРМ!__</span> C компиляторы могут оптимизировать вычисления способами, нарушающими стандарт, если не указаны специальные флаги компиляции. 

### <span style="background-color:green">3.2.2 АРИФМЕТИЧЕСКЕ ОПЕРАЦИИ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

Что важно знать:

1. Числа с плавающей запятой похожи на вещественные, но не являются одним и тем же - числа с плавающей запятой, в отличие от вещественных, ограничены по величине и точности, операции сложения и умножения не являются ассоциативными, распределительный закон не выполняется.
2. Типы с плавающей запятой не могут точно представить все вещественные значения, даже если те состоят из небольшого количества десятичных цифр.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Не используйте переменные с плавающей запятой в качестве счетчиков в циклах

### <span style="background-color:green">3.2.3 ЗНАЧЕНИЯ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

#### <span style="background-color:green">3.2.3.1 НОРМАЛИЗВАОННЫЕ ЧИСЛА</span>

Ведущая единица мантиссы не хранится явно, но учитывается.

Точность (количество значащих бит мантиссы):
1. float — 24 бита
2. double — 53 бита
3. long double — 113 бит (для 128-битного формата IEC 60559)

#### <span style="background-color:green">3.2.3.2 ДЕНОРМАЛИЗВАОННЫЕ ЧИСЛА</span>

Используются для представления очень малых значений, близких к нулю.

Имеют минимально возможный порядок, а ведущая единица мантиссы подразумевается равной 0.

Обладают меньшей точностью, чем нормализованные числа.

#### <span style="background-color:green">3.2.3.3 ОСОБЫЕ ЗНАЧЕНИЯ</span>

<span style="color:orange">_Ноль_</span>: может быть положительным (+0) и отрицательным (-0). Для представления нуля порядок и мантисса равны 0.

<span style="color:orange">_Бесконечность_</span>: +∞ и -∞. Позволяют не прерывать вычисления при переполнении (например, деление ненулевого числа на нуль).

<span style="color:orange">_NaN (Not a Number)_</span>: значение, не соответствующее действительному числу.

<span style="color:orange">_Тихий NaN_</span> — распространяется через арифметические операции без генерации исключения.

<span style="color:orange">_Сигнальный NaN_</span> — вызывает исключение при попытке использования в операции.

#### <span style="background-color:green">3.2.3.4 ОБОЗНАЧЕНИЯ В C</span>

<span style="color:violet">__INFINITY__</span> — положительная бесконечность.

<span style="color:violet">__NAN__</span> — тихий NaN.

<span style="color:violet">__SNANF__</span>, <span style="color:violet">__SNAN__</span>, <span style="color:violet">__SNANL__</span> — сигнальные NaN (из расширений TS 18661).

#### <span style="background-color:green">3.2.3.5 КЛАССИФИКАЦИЯ ЗНАЧЕНИЙ: МАКРОС fpclassify</span>

int fpclassify(real-floating x); — анализирует тип числа с плавающей запятой.

Возвращаемые значения (целочисленные константы):

1. <span style="color:violet">__FP_INFINITE__</span> — бесконечность
2. <span style="color:violet">__FP_NAN__</span> — не число
3. <span style="color:violet">__FP_NORMAL__</span> — нормализованное число
4. <span style="color:violet">__FP_SUBNORMAL__</span> — денормализованное число
5. <span style="color:violet">__FP_ZERO__</span> — ноль

```c
#include <math.h>

int fpclassify(real-floating x);

const char *show_classification(double x) {
    switch(fpclassify(x)) {
        case FP_INFINITE:  return "Inf";
        case FP_NAN:       return "NaN";
        case FP_NORMAL:    return "normal";
        case FP_SUBNORMAL: return "subnormal";
        case FP_ZERO:      return "zero";
        default:           return "unknown";
    }
}
```

### <span style="background-color:green">3.2.4 КОНСТАНТЫ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

<span style="color:violet">__Константа с плавающей запятой__</span> — это десятичное или шестнадцатеричное число, представляющее вещественное значение со знаком. Такие константы следует использовать для хранения значений с плавающей запятой, которые нельзя изменить.

У всех констант с плавающей запятой есть тип. При отсутствии суффикса используется тип <span style="color:orange">_double_</span>; тип <span style="color:orange">_float_</span> имеет суффикс f или F, а суффиксы l и L предназначены для типа <span style="color:orange">_longdouble_</span>.

## <span style="background-color:green">3.3 АРИФМЕТИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ</span>

Зачем нужно <span style="color:violet">__приведение типов__</span>:

1. Необходимость представить значение одного типа (например, float) в другом типе (например, int), например, для передачи в функцию, ожидающую определённый тип.
2. Важно: перед преобразованием убедиться, что значение может быть представлено целевым типом (без потерь или с предсказуемым результатом).

Виды приведения:

1. <span style="color:violet">__Явное приведение (cast)__</span>: операция, записываемая в виде "(тип) выражение". Приведение к меньшему типу span style="color:orange">_может изменить значение_</span>, если оно не помещается.
2. <span style="color:violet">__Неявное преобразование__</span>: автоматически выполняется компилятором в выражениях со смешанными типами.

```c
int si = 5;
short ss = 8;
long sl = (long)si;               // безопасно: int → long (меньший к большему)
unsigned short us = (unsigned short)(ss + sl); // потенциально небезопасно (больший к меньшему)
```

Правила неявных преобразований основаны на трёх концепциях:

1. Ранг преобразования (целочисленные ранги).
2. Повышение разрядности целочисленных значений (integer promotion).
3. Обычные арифметические преобразования (usual arithmetic conversions).

### <span style="background-color:green">3.3.1 РАНГ ПРЕОБРАЗОВАНИЯ ЦЕЛОЧИСЛЕНЫХ ТИПОВ</span>

<span style="color:violet">__Ранг преобразования__</span> — это порядковый номер целочисленного типа, определяющий правила неявного приведения (повышения) типов в выражениях. Правила ранжирования описаны в стандарте C (<span style="color:orange">_ISO/IEC 9899:2018, §6.3.1.1_</span>).

Основные правила:

1. <span style="color:violet">__Знаковые типы__</span>: все знаковые целочисленные типы имеют разные ранги, даже если их размер одинаков (например, int и long могут иметь одинаковый размер, но разные ранги).
2. <span style="color:violet">__Порядок возрастания ранга (знаковые)__</span>: signed char → short int → int → long int → long long int. Чем больше возможный диапазон, тем выше ранг.
3. <span style="color:violet">__Беззнаковые типы__</span>: ранг беззнакового типа равен рангу соответствующего знакового типа (например, unsigned int имеет тот же ранг, что и int).
4. Беззнаковый vs знаковый с меньшей точностью: любой знаковый тип <span style="color:orange">_имеет более высокий ранг_</span>, чем любой беззнаковый тип с меньшей точностью (например, ранг int выше ранга unsigned short).
5. <span style="color:violet">__Тип char__</span>: имеет тот же ранг, что и signed char и unsigned char.
6. <span style="color:violet"> Тип _Bool</span>: <span style="color:orange">_имеет самый низкий ранг_</span> среди всех стандартных целочисленных типов.
7. <span style="color:violet">__Перечислимые типы (enum)__</span>: ранг перечисляемого типа равен рангу его совместимого целочисленного типа (обычно signed int или unsigned int).
8. <span style="color:violet">__Расширенные целочисленные типы__</span>: для них правила определяются реализацией, но должны соблюдать общий порядок (знаковые выше беззнаковых меньшей точности и т.д.).

### <span style="background-color:green">3.3.2 ПОВЫШЕНИЕ РАЗРЯДНОСТИ ЦЕЛОЧИСЛЕННЫХ ЗНАЧЕНИЙ</span>

<span style="color:violet">__Малый тип__</span> - целочисленный тип, ранг преобразования которого ниже, чем у int или unsigned int (например, char, short).

<span style="color:violet">__Повышение разрядности__</span> - автоматическое приведение малых типов к int или unsigned int при использовании в выражениях.

Цели повышения:

1. <span style="color:orange">_Производительность_</span>: операции выполняются с размером, естественным для архитектуры.
2. <span style="color:orange">_Предотвращение ошибок переполнения_</span>: промежуточные вычисления идут в более ёмком типе.

> Пример (без повышения была бы ошибка)

```c
signed char c1 = 100, c2 = 3, c3 = 4, cresult;
cresult = c1 * c2 / c3; // c1, c2, c3 повышаются до int
```

> Без повышения c1 * c2 = 300 не поместилось бы в signed char (диапазон -128..127).

Исторически (до C89) использовалось <span style="color:orange">_сохранение беззнаковости_</span>: малый беззнаковый тип → unsigned int, или <span style="color:orange">_сохранение значения_</span>: малый тип → int, если int может представить все значения; иначе → unsigned int. Сейчас же выбран подход <span style="color:orange">_сохранение значения_</span> как менее подверженный ошибкам, либо принудительное изменение явным приведением.

Повышение зависит от архитектуры:

1. 32-битные архитектуры (например, x86): int — 32 бита. unsigned char (8 бит) и unsigned short (16 бит) повышаются до signed int, так как все их значения помещаются в int.
2. 16-битные архитектуры: int — 16 бит. unsigned char (8 бит) → signed int (все значения помещаются). unsigned short (16 бит) → unsigned int, так как некоторые значения unsigned short (например, 65535) не помещаются в 16-битный signed int.
   
### <span style="background-color:green">3.3.3 ОБЫЧНЫЕ АРИФМЕТИЧЕСКИЕ ПРЕОБРАЗОВАНИЯ</span>

<span style="color:violet">__Обычные арифметические преобразования__</span> — это правила выбора общего типа за счет балансирования обоих операндов бинарной операции или путем балансирования второго и третьего аргументов условной операции (?:).

Автоматический выбор общего типа для операндов бинарных операций (например, +, -, *, /, %, <, >, ==, &, ^, |, ?:), чтобы <span style="color:orange">_выполнить операцию над значениями одного типа_</span>. Применяются к операндам после их повышения разрядности (integer promotion).

Приоритет правил (порядок проверки):

- а. Если хотя бы один операнд имеет плавающий тип:
  1. long double → второй операнд приводится к long double.
  2. Иначе double → второй операнд приводится к double.
  3. Иначе float → второй операнд приводится к float.
  4. Иначе (оба операнда целые) → переход к целочисленным правила
  5. Пример: double + int → int преобразуется в double.
- б. Если оба операнда целые (после повышения разрядности):
  1. Одинаковые типы → преобразований не требуется.
  2. Оба знаковые или оба беззнаковые → меньший ранг приводится к большему (например, int + long → int → long).
  3. Беззнаковый операнд имеет ранг >= ранга знакового → знаковый операнд приводится к беззнаковому типу (например, int + unsigned int → int → unsigned int).
  4. Знаковый тип может представить все значения беззнакового → беззнаковый операнд приводится к знаковому (например, unsigned int + signed long long, если long long вмещает весь диапазон unsigned int → unsigned int → signed long long).
  5. Иначе → оба операнда приводятся к беззнаковым версиям своих типов.

<span style="background-color:red; color: black">__АЛАРМ!__</span> При сомнениях в результате преобразования рекомендуется явное приведение типов, но без злоупотреблений, чтобы не отключать диагностику компилятора.

### <span style="background-color:green">3.3.4 ПРИМЕР АВТОМАТИЧЕСКОГО ПРИВЕДЕНИЯ ТИПОВ</span>

Следующий пример иллюстрирует использование порядка приведения и повышения разрядности целочисленных типов, а также обычные арифметические преобразования. Этот код проверяет равенство между значением c типа signedchar и значением ui типа unsignedint. Мы будем исходить из того, что он компилируется для архитектуры x86:

```c
unsigned int ui = UINT_MAX;
signed char c = -1;
if (c == ui) {
  puts("-1 equals 4,294,967,295");
}
```

Переменная c имеет тип signedchar. Поскольку signedchar по своему рангу целочисленных преобразований уступает типам int и unsignedint, во время сравнения значение, хранящееся в c, расширяется до объекта типа signedint. Это достигается за счет расширения знака исходного значения с 0xFF до 0xFFFFFFFF. Такое приведение используется для преобразования значений со знаком в более широкие объекты. Разряд, хранящий знак, копируется в каждый разряд расширенного объекта. Данная операция сохраняет знак и величину в ходе приведения меньшего целочисленного значения со знаком к большему.

Затем происходят обычные арифметические преобразования. Поскольку операнды операции равенства (==) имеют одинаковый ранг, но у одного из них есть знак, а у другого — нет, операнд со знаком приводится к беззнаковому целочисленному типу другого операнда. Затем выполняется 32-битная беззнаковая операция сравнения. Расширенное и преобразованное значение c совпадает с UINT_MAX, поэтому сравнение возвращает 1 и фрагмент кода выводит следующее:

<span style="color:orange">_-1 equals 4,294,967,295_</span>

### <span style="background-color:green">3.3.5 БЕЗОПАСНОЕ ПРИВЕДЕНИЕ ТИПОВ</span>

Приведение типов (явное или неявное) может дать результат, непредставимый в целевом типе. Лучше избегать смешивания типов, но при необходимости — проверять возможность преобразования.\

#### <span style="background-color:green">3.3.5.1 ПРИВЕДЕНИЕ ЦЕЛОЧИСЛЕННЫХ ЗНАЧЕНИЙ</span>

<span style="color:orange">_Безопасно всегда_</span> - приведение к большему типу (с тем же знаком или беззнаковому). Требует проверки приведение к меньшему типу или изменение знака.

Необходимо убедиться, что исходное значение находится в диапазоне [MIN, MAX] целевого типа.

> Пример

```c
#include <errno.h>

#include <limits.h>

errno_t do_stuff(signed long value) {
  if ((value < SCHAR_MIN) || (value > SCHAR_MAX)) {
    return ERANGE;
  }
  signed char sc = (signed char)value; // приведение типов глушит предупреждения
}
```

#### <span style="background-color:green">3.3.5.2 ПРИВЕДЕНИЕ ЦЕЛОЧИСЛЕННЫХ ЗНАЧЕНИЙ К ТИПАМ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

Точное представление: значение не меняется.
В пределах диапазона, но неточно: округление до ближайшего представимого значения (зависит от реализации).
Вне диапазона: неопределённое поведение (UB).

#### <span style="background-color:green">3.3.5.3 ПРИВЕДЕНИЕ ЗНАЧЕНИЙ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ К ЦЕЛОЧИСЛЕННЫМ ТИПАМ</span>

Когда конечное значение с плавающей запятой приводится к любому целочисленному типу (кроме bool), дробная часть отбрасывается. Если значение целой части нельзя представить с помощью целочисленного типа, то поведение не определено.

#### <span style="background-color:green">3.3.5.4 УМЕНЬШЕНИЕ РАЗРАЯДНОСТИ ЗНАЧЕНИЙ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

К более крупному типу (float → double): всегда безопасно.

К меньшему типу (double → float):

1. Похоже на правила пункта 3 (целые → плавающие): если значение вне диапазона → UB.
2. Если реализация поддерживает IEEE 754 (Приложение F) и бесконечности, то уменьшение разрядности всегда успешно (значения либо точно представимы, либо превращаются в ∞).