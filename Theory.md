# <span style="background-color:chocolate">ОБЩИЕ ЗАМЕТКИ</span><br>
<span style="background-color: green">Можно скомпилиривать как при помощи gcc, так и cc - второй создаст файл a.out. Или, как у gcc, можно добавить флаг -o и скомпилить файл с нужным именем.</span>

C имеет две потенциальные _<span style="color:orange">_среды выполнения_:
1. <span style="color:orange">_минимальную_ - freestanding</span>
2. <span style="color:orange">_полноценную_ - hosted</span><br>

<span style="background-color:red; color:black">---Минимальная среда выполнения---</span>
1. Может существовать вне ОС
2. Используется в создании встраиваемых систем
3. Предоставляет минимальный набор библиотечных функций, а объявление точки входа отличается в разных реализациях

Программы на C состоят из <span style="color:orange">_процедур (функций, методов)_</span>, которые:
1. имеют определённый тип и могут возвращять определённые значения (тип функции = тип возвращаемого значения)
2. могут принимать аргументы

# <span style = "background-color:chocolate">ВВЕДЕНИЕ В C</span>

## <span style="background-color:green">Директивы препроцессора</span><br>

<span style="color:violet">__Директива препроцессора__</span> — это специальная команда, которую препроцессор распознаёт и выполняет для предварительной обработки текста программы. Препроцессор обрабатывает исходный код до компиляции, и директивы указывают, как выполнять определённые действия. <br>
<span style="color:violet">__#include__</span> - ведет себя так, будто вместо нее подставляется содержимое указанного файла. По сути, подключает нужный файл.

## <span style="background-color:green">Стандартные библиотеки</span><br>

<span style="color:violet">__stdio.h__</span> - I/O - содержит методы ввода/вывода.<br>
<span style="color:violet">__stdlib.h__</span> - функции общего назначения.<br>
<span style="color:violet">__stdbool.h__</span> - для использования логического типа <span style="color:orange">__Bool_</span>.<br>
<span style="color:violet">__wchar.h__</span> - для более глубокой работы с широкими символами <span style="color:orange">__Bool_</span>.<br>
<span style="color:violet">__limits.h__</span> - файл, который определяет константы, связанные с ограничениями типов данных.<br>
<span style="color:violet">__stdint.h__</span> - файл, позволяющий работать с целочисленными типами.<br>
<span style="color:violet">__inttypes.h__</span> - файл, который определяет константы, связанные с ограничениями типов данных.<br>

## <span style="background-color:green">Входная точка программы</span>

<span style="color:violet">__int main()__</span>  - входная точка программы<br>
<span style="color:violet">__(void)__</span> - даёт понять, что main <span style="color:orange">_ничего не принимает._</span>

Предназанчение возаращемого функцией main значения - <span style="color:orange">_указать, как завершилась программа - успешно или нет_</span>

### <span style="background-color:red; color:black">---Как происходит вход/выход в/из программы:---</span><br>

#### ВХОД 
main - входная точка, выполняемая при запуске программы
выполняется функция main в серверной среде, после запуска из командной строки или другой программы

#### ВЫХОД 
return (0 или 1, или макросы, представляющие эти значения) - выход из программы -- среда исполнения получает возврат из функции main, по которому может проверить состояние проги и определить, насколько успешен был вызов.

#### ЗАМЕЧАНИЯ 
return __value__ в main = exit(__value__) 

## <span style="background-color:green">ФОРМАТИРОВАННЫЙ ВЫВОД</span><br>

<span style="color:violet">__printf__</span> (или ее вариации) - функция, для форматированного вывода. Принимает строку, которая описывет формат вывода и произвольное количество аргументов, представляющих значения для вывода. Сама же возвращает количество выведенных символов, а при возникновении ошибки — отрицательное значение 
> <span style="color:red">АЛАРМ! ОПАСНОСТЬ! Никогда пользовательские данные не должны быть первым аргументом функции (т.е. как строку формата), т.к это может привести к утечкам памяти или инфы. Например:

```c
int main() {
    char buffer[100];
    
    // Симуляция ввода злоумышленника
    char *malicious_input = "%08x %08x %08x %08x";
    
    printf("=== УЯЗВИМЫЙ ВЫЗОВ ===\n");
    printf(malicious_input);  // ОПАСНО!
    printf("\n");
    
    printf("=== БЕЗОПАСНЫЙ ВЫЗОВ ===\n");
    printf("%s", malicious_input);  // БЕЗОПАСНО
    printf("\n");
    
    return 0;
}
```

>Вывод уязвимой версии может показать:
0041a2c0 00000001 7ffd42a8 0041a2c0
(это служебные данные из стека - УТЕЧКА ИНФОРМАЦИИ!)
</span>

### <span style="background-color:red; color:black">__Спецификаторы формата__</span> (не все)
1. <span style="color:violet">__%s__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_строку_</span>
2. <span style="color:violet">__%d__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_целое число_</span>
3. <span style="color:violet">__%f__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_число с плавающей точкой_</span>
4. <span style="color:violet">__%c__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_символ_</span>
5. <span style="color:violet">__%x__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_шестнадцатиричное число_</span>

### <span style="background-color:red; color:black">Алфавитные управляющие последовательности</span>
Необходимы для вывода неотображаемых символов. Список последовательностей:
1. <span style="color:violet">__\n__</span> - перевод строки

## <span style="background-color:green">БИБЛИОТЕЧНЫЕ МЕТОДЫ И МАКРОСЫ</span>

<span style="color:violet">__int puts(const char*)__</span>
1. записывает полученный аргумент в поток <span style="color:orange">_stdout (консоль или терминал)_</span>, добавляя к выводу '\n'
2. если во время вывода возникла ошибка, возвращается макрос EOF (представляющий отрицательное число) - иначе целое неотрицательное значение
    
<span style="color:violet">__EXIT_SUCCESS__</span>
1. макрос, зачастую имеет такое определение - #define EXIT_SUCCESS 0

<span style="color:violet">__EOF__</span>
1. макрос

## <span style="background-color:green">КОМПИЛЯТОРЫ</span>
### <span style="background-color:red; color:black">GNU Compiler Collection</span>
<span style="color:violet">__GCC__</span> — стандартный компилятор в системах Linux (также есть версии для других платформ). Поддерживает <span style="color:orange">_C_</span>, <span style="color:orange">_C++_</span>, <span style="color:orange">_Objective-C_</span> и другие языки<br>

### <span style="background-color:red; color:black">Clang</span>
<span style="color:violet">__Clang__</span> — фронтенд для компиляторов для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, созданный совместно с фреймворком LLVM. Цель проекта — <span style="color:orange">_создание замены GNU Compiler Collection (GCC)_</span>.<br>

### <span style="background-color:red; color:black">MICROSOFT VISUAL STDUIO</span>
<span style="color:violet">__Microsoft Visual Studio__</span> — не столько компилятор, сколько <span style="color:orange">_самая популярная IDE для C/C++ на Windows_</span>, но поставляется вместе с компилятором для C/C++<br>

### <span style="background-color:red; color:black">Переносимость</span>
Компиляторы не поддерживают весь спектр спецификаций стандарта C (в том числе и промежуточных). В целом, <span style="color:orange">_реа­лизации C развиваются медленно, и многие компиляторы существенно отстают от стандарта языка_</span>.

1. <span style="color:orange">_Идеал vs Реальность_</span>: Программы на C в идеале должны строго следовать стандарту для максимальной переносимости. На практике это недостижимо.

2. <span style="color:orange">_Практический подход_</span>: В реальности код пишут для конкретных реализаций (платформ), что позволяет использовать их особенности и не мешает работе на нескольких платформах.

3. <span style="color:orange">_Проблемы переносимости_</span>: Стандарт C явно выделяет пять видов поведения, которые мешают переносимости:

- <span style="color:orange">_Поведение, определяемое реализацией (во избежание проблем, нужно стремиться писать код, поведение которого не будет зависеть от конкретной реализации языка (стандарт языка и компилятор))_</span>
- <span style="color:orange">_Неуточнённое поведение (стандарт C допускает несколько вариантов работы программы, но не указывает, какой именно должен быть выбран -> т.е. все варианты корректны, но результат выполнения - разный)_</span>
- <span style="color:orange">_Неопределённое поведение_</span>
- <span style="color:orange">_Поведение, зависящее от региональных параметров_</span>
- <span style="color:orange">_Распространённые расширения_</span>

#### <span style="background-color:red">Неопределенное поведение</span>
<span style="color:violet">__Неопределённое поведение__</span> - поведение, для которого стандарт C не устанавливает никаких требований.

<span style="color:red">Сущность</span>:<br>

1. Результат непредсказуем — от некорректного вывода до сбоя программы

2. Примеры: переполнение знакового целого, разыменование некорректного указателя

3. Стандарт явно не определяет последствия таких действий

<span style="color:red">Возможные последствия:</span>:<br>

1. Непредсказуемые результаты без предупреждений

2. Поведение, специфичное для конкретной платформы

3. Аварийное завершение программы

<span style="background-color:red; color: black">__АЛАРМ!__</span> Нужно избегать неопределённого поведения, если только реализация явно не определяет его через расширения языка.</span>

# <span style="background-color:chocolate">ОБЪЕКТЫ, ФУНКЦИИ И ТИПЫ</span><br>

## <span style="background-color:green">ОБЪЕКТЫ</span>
<span style="color:violet">__Объект__</span> — это хранилище, в котором можно представлять значения. По стандарту <span style="color:orange">_ISO/IEC 9899:2018_</span>, <span style="color:violet">__объект__</span> - область хранилища данных в среде выполнения, содержимое которого может представлять значения» с примечанием: «при обращении к объекту можно считать, что он обладает определенным типом». Один из примеров объекта - <span style="color:orange">_переменная_</span>.

<span style="color:violet">__Переменная__</span> - это контейнер для значения. Они имеют объявленный <span style="color:orange">_тип_</span>, указывающий на то, какого рода объект представляет его значение, а также <span style="color:orange">_имя_</span> - идентификатор, по которому можно обратиться к созданной переменной.

У объектов есть понятие <span style="color:violet">__времени жизни__</span> или, как в других языках, <span style="color:violet">__жизненного цикла__</span> - это период выполнения программы, во время которого объект существует. Вне периода к объекту обратиться нельхя, т.к. он уже не будет существовать.

<span style="color:orange">_Время хранения_</span> определяет <span style="color:orange">_время жизни_</span> объекта.

## <span style="background-color:green">ТИПЫ (СОВМЕЩЕНО С ГЛАВОЙ 3)</span>

<span style="color:violet">__Тип__</span> - характеристика данных, определяющая размер выделяемой для объекта памяти и представление объекта в памяти, допустимые с объектом операции и его диапозон значений.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Каждый тип в С является либо <span style="color:orange">_объектным_</span>, либо <span style="color:orange">_функциональным_</span>.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Важность типа объясняется тем, что набор битов, представляющий объект определённого типа, будет иметь другое значение, если интерпретировать как объект другого типа. 

> <span style="background-color:#00a572; color: white">__Пример__</span> В IEEE 754 (стандарт IEEE для арифметических операций с плавающей запятой) число 1 можно представить как 0x3f800000 (IEEE 754–2008). Этим же набором битов, интерпретированным как целое число, можно представить число 1 065 353 216.

<span style="color:orange">_Базовые типы_</span>:

1. <span style="color: violet">int</span> - целочисленный
2. <span style="color: violet">float</span> - вещественный
3. <span style="color: violet">char</span> - символьный
4. <span style="color: violet">void</span> - пустой тип (функция с этим типом будет считаться бестиповой)

### <span style="background-color:green">ОБЪЕКТНЫЕ ТИПЫ</span>
Делятся на логические, символьные и численные типы

#### <span style="background-color:green">ЛОГИЧЕСКИЕ ТИПЫ</span>
Могут хранить либо 0, либо 1. 
<span style="color: violet">Лочиеский тип (булевый, _Bool)</span> впервые появился в C99, начинается с подчёркивания, чтобы не возникало путаницы с пользовательскими идентификаторами bool и boolean, которые были объявлены в существующихх программах. 

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если название начинается с нижнего подчеркивания и заглавной буквы следом, то оно считается <span style="color:orange">_зарезервированным_</span>.  

Может быть использован при подключении заголовочного файла <span style="color:orange">_stdbool.h_</span>.
>Пример в functions_objects_and_types/jokes_with_types.c

Можно объявлять как при помощи <span style="color:orange">__Bool_</span>, так и <span style="color:orange">_bool_</span>, но лучше использовать bool, так как именно ему отдаётся предпочтение в долгосрочной перспективе. При присвоении значения true, это значение разворачивается в целочисленную константу 1, а при присвоении false - в 0.

#### <span style="background-color:green">СИМВОЛЬНЫЕ ТИПЫ</span>
Есть три символьных типа:

1. <span style="color: violet">__char__</span>
2. <span style="color: violet">__unsigned char__</span>
3. <span style="color: violet">__signed char__</span>

В любой реализации, char имеет одинаковые с unsigned char или signed char (зависит от реализации) <span style="color:orange">_выравнивание_</span>, <span style="color:orange">_размер_</span>, <span style="color:orange">_диапазон_</span>, <span style="color:orange">_представление_</span> и <span style="color:orange">_поведение_</span>. Но при этом char - <span style="color:orange">_отдельный тип_</span>, не совместимый с другими символьными типами.

Обычно используется тип char для представления символьных данных. Объекты этого типа хранят минимальный набор символов, необходимых среде выполнения, включая:

1.  строчные и заглавные латинские буквы
2. десятичные цифры (все от 0 до 9)
3. пробельные символы
4. знаки препинания
5. управляющие символы

Для хранения небольших целых значений со знаком или без лучше использовать <span style="color:orange">_signed char_</span> или <span style="color:orange">_unsigned char_</span>.

Широкие символы <span style="color:orange">_wchar_t_</span>:
1. Решает проблему отсутствия неанглийских букв в char
2. Поддерживает большие наборы символов
3. Обычно занимает 16 или 32 бита
4. Стандартная библиотека предоставляет функции для работы с char и wchar_t

> <span style="background-color:red; color: black">__АЛАРМ!__</span> При инициализации значения wchar_t нужно использовать <span style="color:orange">_L_</span> перед литералом строки или символа - для того, чтобы была работа именно с wchar_t, работающим с символами юникода, а также нужен <span style="color:orange">_setlocale(LC_ALL, "");_</span> - для обозначения работы с другими локалями (не английской, в данном случае - в локали окружения). Также есть функции для работы с широкими символами, например <span style="color:orange">_wprintf_</span> из библиотеки <span style="color:orange">_wchar.h_</span> - её лучше использовать для вывода нескольких широких символов или при смешанном выводе

> <span style="background-color:red; color: black">__АЛАРМ v2!__</span> Одновременно использовать <span style="color:orange">_printf_</span> и <span style="color:orange">_wprintf_</span> нельзя - после использования <span style="color:orange">_printf_</span> выходной поток переходит в <span style="color:orange">_байтовый_</span> режим (а не <span style="color:orange">_широкий_</span>), соответственно, нужно использовать какую-то одну - или <span style="color:orange">_printf_</span>, или <span style="color:orange">_wprintf_</span>.

> Примеры в functions_objects_and_types/jokes_with_types.c.

#### <span style="background-color:green">ЧИСЛЕННЫЕ ТИПЫ</span>

##### <span style="background-color:green">ЦЕЛОЧИСЛЕННЫЕ ТИПЫ</span>

Используются для представления отрицательных и положительных, а также нулевых значений:

1. <span style="color: violet">__signed char__</span>
2. <span style="color: violet">__short int__</span>
3. <span style="color: violet">__int__</span>
4. <span style="color: violet">__long int__</span>
5. <span style="color: violet">__long long int__</span>

При объявлении, если объявляется не int или signed char, <span style="color:orange">_можно опустить int_</span>.

Для каждого знакового типа есть <span style="color:orange">_аналог_</span> - безнаковый тип, т.е.:

1. <span style="color: violet">__unsigned char__</span>
2. <span style="color: violet">__unsigned short int__</span>
3. <span style="color: violet">__unsigned int__</span>
4. <span style="color: violet">__unsigned long int__</span>
5. <span style="color: violet">__unsigned long long int__</span>

С помощью беззнаковых типов можно представлять только положительные и нулевые значения.

В целом, целочисленные типы используются для обозначения целых чисел. Размер этих типов может отличаться на разных платформах, но <span style="color:orange">_диапазон значений гарантирован_</span>.

> Стандарт гарантирует, что диапазон каждого более широкого типа покрывает диапазон предыдущего

Конкретный размер разных целочисленных типов можно определить по минимально и максимально допустимым значениям, указанным в заголовочном файле <span style="color:orange">_limits.h_</span>.

> Тип int обычно имеет естественный размер, вытекающий из архитектуры среды выполнения - в 16-битной архитектуре это 16 бит, а в 32-битной — 32 бита. Выделить целочисленные значения нужного размера можно при помощи более точных int-типов (у них точно задана <span style="color:orange">_битность_</span>), указаных в файлах <span style="color:orange">_stdint.h_</span> и <span style="color:orange">_inttypes.h_</span>, например, <span style="color:orange">_uint32_t_</span> или самые широкие <span style="color:orange">_uintmax_t_</span> и <span style="color:orange">_intmax_t_</span>.

##### <span style="background-color:green">ПЕРЕЧИСЛЯЕМЫЕ ТИПЫ</span>
<span style="color: violet">__Перечисления__</span> - позволяет определить тип, который назначает <span style="color:orange">_имена (перечислители)_</span> целым значениям, когда требуется перечисляемый набор постоянных значений.

Если у первого перечислителя в перечислении не будет указано значение, он автоматически примет значение <span style="color:orange">_0_</span>. Каждая следующая константа без оператора присваивания =, будет принимать значение на единицу больше предыдущего. Каждому перечислителю можно задать значение, при чём <span style="color:orange">_значения не обязательно должны быть уникальными_</span>.

> Значения констант в перечислении должны быть совместимы с типом int, хотя в действительности их тип зависит от реализации. Например, <span style="color:orange">_Visual C++ использует signed int, а GCC — unsigned int_</span>.

##### <span style="background-color:green">ТИПЫ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ</span>

1. <span style="color: violet">__float__</span>
2. <span style="color: violet">__double__</span>
3. <span style="color: violet">__long double__</span>

Арифметические операции с плавающей запятой похожи на операции с числами с плавающей запятой и зачастую служат для них моделью. Стандарт языка С допускает разные варианты представлений чисел с плавающей запятой, и в большинстве систем реализован соответствующий стандарт IEEE (IEEE 754–2008). Выбор того или иного варианта зависит от реализации.

#### <span style="background-color:green">ТИП VOID</span>

<span style="color: violet">__void__</span> - не может принимать значения, с его помощью можно сигнализировать о том, что ваша функция не возвращает значение или не принимает аргументов

Есть производный тип <span style="color:orange">_minvoid*_</span>, который означает, что указатель может ссылаться на любой объект.

### <span style="background-color:green">ФУНКЦИОНАЛЬНЫЕ ТИПЫ</span>

Являются <span style="color:orange">_производными_</span>, т.е. основаны на типе возвращаемого значения, а также на количестве и типах параметров функции, при чём тип возвращаемого значения не может быть массивом.

### <span style="background-color:green">ПРОИЗВОДНЫЕ ТИПЫ</span>

<span style="color: violet">__Производные типы__</span> - это типы, основанные на других типах - указатели, массивы, определения типов, структуры, объединения.

#### <span style="background-color:green">УКАЗАТЕЛИ</span>

<span style="color:violet">__Указатель__</span> - переменная, которая хранит <span style="color:orange">_адрес памяти_</span> другой переменной или функции. <span style="color:violet"> __Адрес__</span> - область памяти, в которой хранятся объекты или функции.

<span style="color:violet">__Ссылочный тип__</span> - тип указателя, определяемый типом данных, на которые он ссылается.

<span style="background-color:red; color: black">__АЛАРМ!__</span> <span style="color:orange">_Объектные указатели_</span> (то есть указатели на объект) отличаются от <span style="color:orange">_функциональных указателей_</span> (то есть указатели на функцию) => их нельзя использовать как взаимозаменямые.

```c
void swap(int* a, int* b) {
    int temp = *a;

    *a = *b;
    *b = temp;
}
```
> int temp = *a; - унарная операция * - <span style="color:violet">__операция разыменовывания__</span>, т.е. получение значения по адресу памяти, куда указывает указатель а. Если операнд указывает на функцию, то результатом использования * будет ее обозначение (designator), а если на объект, то результатом будет значение этого объекта.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Если указатель не ссылается на действительный объект или функцию, то может произойти что-то плохое (например, прога крашнется)

```c
swap(&a, &b);
```
> унарная операция & - операция взятия адреса

```c
#include <stdlib.h>
#include <stdio.h>

void swap(int*, int*);

int main(void) {
    int a = 15, b = 71;
    printf("a = %d, b = %d до вызова функции\n", a, b);

    swap(&a, &b);
    printf("a = %d, b = %d после вызова функции\n", a, b);

    return EXIT_SUCCESS;
}

void swap(int* a, int* b) { //параметры, при вызове функции, будут содержать копии аргументов, т.е. переданных адресов - имитация передачи аргументов по ссылке
    int temp = *a;

    *a = *b;
    *b = temp;
}
```

> Считается <span style="color:orange">_производным типом или ссылочным типом_</span> (см. типы - это выше) - потому что указатель - производный тип от типа функции или объекта, на которые ссылается

> Также обратите внимание на указатель на void (void*). Он может хранить адрес любого объекта, но не может быть разыменован без приведения к конкретному типу.

#### <span style="background-color:green">МАССИВЫ</span>

<span style="color: violet">__Массив__</span> — это последовательность объектов одного и того же типа, выделенных один за другим. Тип массива характеризуется <span style="color:orange">_типом и количеством его элементов_</span>.

<span style="color:orange">_Квадратные скобки ([]) используются для идентификации элемента массива_</span>.

Идентификатор массива - это <span style="color:orange">_укзатаель на первый элемент массива_</span>.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Индексация в массиве с 0.

> Взять адрес i-го элемента массива можно с помощью операции +. 
```c
int main(void) {
    char str[11];

    char* array_member = str + 5;
}
``` 
> В силу того, что элементы массива находятся в памяти ровно друг за другом, то проблем со смещением указателя не возникнет. Кстати, операция str + 5 эквивалентна операции &str[5]. P.S.NAGGER ответь: почему так?

> Двумерные массивы (к слову, массивы могут быть <span style="color:orange">_многомерными_</span>) называют <span style="color:orange">_матрицами_</span>. По сути, <span style="color: violet">__многомерный массив__</span> - это <span style="color:orange">_массив массивов_</span>.

```c
void func(int arr[5]);

int main(void) {
    unsigned int i = 0;
    unsigned int j = 0;
    int arr[3][5];
    func(arr[i]);
}

void func(int arr[5]) {
    int x = arr[j];

    return 0;
}
```

При использовании выражения arr[i] (эквивалентного *(arr+i)), происходит следующее:

1. Массив arr преобразуется в <span style="color:orange">_указатель_</span> на массив из пяти элементов типа int, начиная с arr[i], т.е. происходит превращение в указатель на первый элемент массива arr[i].

2. Индекс i подстраивается под тип arr за счет <span style="color:orange">_умножения_</span> на размер одного массива из пяти объектов int, т.е. мы получаем адрес первого элемента очередного массива (1 * 5 - так вычисляется адрес arr[1]).

3. Результаты первых двух шагов <span style="color:orange">_складываются_</span>.

4. Происходит <span style="color:orange">_косвенное обращение к результату_</span>, чтобы получить массив из пяти элементов типа int.

#### <span style="background-color:green">СТРУКТУРЫ</span>

<span style="color: violet">__Структура__</span> - объект, содержащий последовательно выделенные объекты-члены.

Каждый объект обладает собственным именем, а тип может быть разный.

> Чем-то похож на тип данных <span style="color:orange">_record ("запись")_</span> из других ЯП (например, Java)

### <span style="background-color:green">ОПРЕДЕЛЕНИЯ ТИПОВ</span>

<span style="color: violet">__typedef__</span> - используется для создания псевдонима для <span style="color:orange">_существующего_</span> типа. 

<span style="background-color:red; color: black">__АЛАРМ!__</span> НОВОГО ТИПА typedef <span style="color:orange">_НЕ СОЗДАЁТ_</span>.

> Идентификаторы, находящиеся в стандартных заголовочных файлах и заканчивающиеся на <span style="color:orange">__t_</span>, являются <span style="color:orange">_определениями типов_</span> (псевдонимами для существующих типов). Программистам не нужно соблюдать это соглашение - стандарт C резервирует все такие идентификатора, соответствующие шаблонам <span style="color:orange">_int[0-9a-z_]*_t_</span> и <span style="color:orange">_uint[0-9a-z_]*_t_</span>, а спецификация <span style="color:orange">_POSIX (Portable Operating System Interface — переносимый интерфейс операционных систем)_</span> резервирует все идентификаторы, которые заканчиваются на <span style="color:orange">__t_</span>. В случае определения идентификатора с таким именем может возникнуть конфликт с именами, которые используются реализацией. Это, в свою очередь, может спровоцировать проблемы, которые будет сложно диагностировать.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> 

## <span style="background-color:green">ФУНКЦИИ</span>

<span style="color: violet">__Функция__</span> - это именованный блок кода, который выполняет одну конкретную задачу. Может быть вызвана много раз.

У функции могут быть описаны <span style="color:violet">__параметры__</span> - объекты, которые объявляются вместе с функцией и получают значения при входе в нее, а те самые значения - есть <span style="color:violet">__аргументы__</span>. В языке C передача <span style="color:orange">__аргументов__</span> при вызове происходит <span style="color:orange">_по значению_</span>; то есть когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. Изменение значений параметров в функции не влияет на значения в вызывающем коде, поскольку это разные объекты.

<span style="color: violet">__Прототип (объявление) функции__</span> - сочетание типа возвращаемого значения, имени и параметров функции. Он сообщает компилятору о количестве и типах параметров, которые она принимает. С помощью этой информации компиляторы следят за тем, чтобы в style="color:orange">_определении функции_</span> и в любых ее вызовах использовалось корректное количество параметров с подходящими типами.

> <span style="color: violet">__Определение функции__</span> - реализация функции

При объявлении функции нужно указать ее <span style="color:orange">_имя и тип значения, которое она возвращает_</span>. Если объявление совмещено с определением и предусматривает список параметров, в объявлении каждого параметра необходимо указать идентификатор. Исключение составляет случай, когда имеется только один параметр типа <span style="color:orange">_void_</span>, который не нуждается в идентификаторе.

```c
//int - это спецификатор возвращаемого значения, max(int a,int b) - объявление функции, а {return a > b ? a : b;} - ее тело, т.е. определение
int max(int a, int b)
{ 
    return a > b ? a : b; 
}
```

Если в объявлении функции после типа указан знак *, это значит, что параметр является <span style="color:orange">_указателем_</span> на объект или функцию заданного типа.

Не объекты, но имеют тип, характеризуемый возращаемым значением и числом/типами параметров. (см. функциональные типы)

```c
//1
int f(void);
//2
int *fip();
//3
void g(int i, int j);
//4
void h(int, int);
```
<span style="background-color:red; color: black">__АЛАРМ!__</span> Задать имя параметра не получится, если есть макрос с таким же именем (пример 3 - если бы существовали макросы с именами i или j, то прога не скомпилируется). 

> Но всё же задавать имя параметрам рекомендуется - это способствует написанию <span style="color:orange">_самодокументируемого кода_</span>

<span style="background-color:red; color: black">__АЛАРМ!__</span> В C никогда не следует объявлять функции с пустым списком параметров. Причины:

1. устаревшая возможность языка => может исчезнуть
2. код может быть перенесён в c++, от чего поведение его может измениться (см. далее почему)

> Если переместить функцию fip в c++ (пример 2), то она будет возвращать целочисленный указатель и не будет принимать значений, но при этом в c, даже при одинаковом типе возвращаемого значения - она может принимать любое количество аргументов любого типа.

## <span style="background-color:green">ОБЛАСТИ ВИДИМОСТИ</span>
<span style="color:violet">__Область видимости__</span> - 1) блок кода, в котором возможно обращение к идентификатору. В языке C область видимости может охватывать <span style="color:orange">_файл_</span>, <span style="color:orange">_блок кода_</span>, <span style="color:orange">_функцию_</span>, <span style="color:orange">_прототип(объявление) функции_</span>. 2) регион программы, в котором идентификатор может быть использован

Область видимости определяется местом, где он объявлен:
1. <span style="color:violet">__На уровне файла__</span>. Это значит, что идентификатор доступен на уровне всего файла, где объявлен, а также во всех других файлах, где используется файл объявления. Например, в файле source.h, в самом начале файле, после объявления заголовочного файла, мы определили макрос <span style="color:orange">_nagger_</span>, и если мы подключим этот файл в source_code.c, то мы сможем этим макросом пользоваться в .c файле.
```c
//source.h
#define nagger "NAGGER" 

//source_code.h
#include <source.h>
int main() {
    char* naggers_name = nagger;
}
```

> Макрос не имеет области видмости в общем понимании этого слова, как идентификатор, поэтому вот еще пример

```c
//source.h
void swap(int*, int*);

//source_code.h
#include <source.h>
int main() {
    int a = 0;
    int b = 1;
    swap(&a, &b);
}
```
2. <span style="color:violet">__Блочная область видимости__</span>. Объявленный идентификатор доступн только в том блоке, в котором объявлен. 
```c
int main() {
    int a = 1;
    {
        int temp = 2;
    }

    int b = temp + a; //АЛАРМ!!!!!!!! ОШИБКА!!!!!!!!!
}
``` 
3. <span style="color:violet">__Область видимости в прототипе функции__</span>. Параметры в прототипе видны только в этом прототипе.
```c
int swap(int a, int b);

int main() {
    a = 0; //АЛАРМ!!!!!!!!!!!ОШИБКА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
```
4. <span style="color:violet">__Область видимости функции__</span>. Только для меток. <span style="color:orange">_Метка_</span>, объявленная в функции, видна в любом месте этой функции.
> Про метки будет инфа чуть позже<br>
> В функции, параметры этой функции и локальные переменные имеют блочную область видимости (блоком является тело функции)

Области видимости могут быть <span style="color:orange">_вложенными_</span> и находиться как внутри, так снаружи других блоков.

При объявлении одинаковых идентификаторов в <span style="color:orange">_наружней_</span> и <span style="color:orange">_внутренней_</span> областях видимости, объявленный во внутренней будет перекрвать наружнюю версию.

## <span style="background-color:green">СРОК ХРАНЕНИЯ</span>

<span style="color:violet">__Срок хранения__</span> определяет <span style="color:orange">_время жизни_</span> объекта.

Какие есть сроки хранения:

1. <span style="color:violet">__Автоматический__</span>. Время жизни объекта начинается при выполнении блока и заканчивается вместе с выполнением блока. Например, <span style="color:orange">_параметры функции_</span>.
> Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.
2. <span style="color:violet">__Статический__</span>. Таким сроком хранения обладают объекты, объявленный на уровне файла. Время жизни = <span style="color:orange">_время выполнения программы_</span>, а значения инициализируются ещё до запуска программы.
> При помощи модификатора <span style="color:orange">_static_</span> можно задать статический срок хранения даже переменным с <span style="color:orange">_блочной видимостью_</span>. Смотри файл functions_objects_and_types/jokes_with_lifetime.c
> Статические объекты должны <span style="color:orange">_инициализироваться с помощью константного значения, а не переменной_</span> 
```c
int *func(int i) {
  const int j = i;  // правильно
  static int k = j; // ошибка
  return &k;
}
```
> К константным значениям относятся <span style="color:orange">_константы-литералы_</span> (например, 1, 'a' или 0xFF), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.
3. <span style="color:violet">__Потоковый__</span> - используется в <span style="color:orange">_конкурентном программировании_</span>.
> <span style="color:violet">__Конкурентное программирование__</span> - это подход к разработке программного обеспечения, при котором несколько вычислительных процессов выполняются одновременно, чтобы повысить эффективность и производительность систем. 
4. <span style="color:violet">__Выделенный__</span> или <span style="color:violet">__динамический__</span> - задействован в работе с динамически выделяемой памятью

<span style="background-color:red; color: black">__АЛАРМ!__</span> При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.

## <span style="background-color:green">ВЫРАВНИВАНИЕ</span>

<span style="color:violet">__Выравнивание__</span> - это требование типов объектов, ограничивающее допустимые адреса для размещения объектов. Оно определяет количество байтов между смежными адресами, при котором может быть сохранен объект данного типа. Адрес выровненных данных может быть кратен размеру объекта, и процессор может обрабатывать выровненные и невыровненные данные по-разному. 

Любой компьютер выполняет многобайтный доступ к данным по границам <span style="color:orange">_машинного слова_</span>(выровненный доступ). Однако:

1. Некоторые системы могут также обращаться к невыровненным данным с потерей производительности (либо с ошибками в результате)

2. Другие системы вообще не поддерживают невыровненный доступ"

> <span style="color:violet">__Машинное слово__</span> - естественная единица фиксированного размера для измерения данных, с которыми работают инструкции или аппаратные механизмы процессора.

> <span style="background-color:red; color: black">__АЛАРМ!__</span> Требования к выравниванию могут зависеть от размера машинного слова в конкретном процессоре (обычно это 16, 32 или 64 бита).

В целом, при программировании на C не стоит греть голову о выравнивании, но иногда бывают ситуации, когда решения компилятора о выравнивании памяти приходится переопределять - например, для выравнивания данных на границах строк кэша (адреса должны быть кратны степеням 2). Для этого можно пойти двумя способами:

1. команды компоновки;

2. выделение дополнительной памяти с помощью <span style="color:orange">_malloc_</span> с последующим округлением пользовательского адреса вверх;

3. другие нестандартные средства.

Также гарантируется, что память выделенная при помощи <span style="color:orange">_malloc_</span>, будет достаточно выравнена для всех стандартных типов (включая массивы и структуры). 

> Например, есть структура:
```c
struct nagger {
    char[20] name;
    double money;
}
```
> char[20] потребует 20 байт для хранения данных, bouble - ещё 8, итого - 28 байт на объект структуры. После выравнивания, в некоторых системах для объекта будет выделено 32 байта, а в каких-то 64 (будет округлено до степеней 2) - добавятся <span style="color:orange">_отступы_</span> либо в конец памяти, выделенной для объекта, либо меджу байтами данных <span style="color:orange">_name_</span> и <span style="color:orange">_money_</span> - чтобы поле money было выровнено по адресу, кратному 8, и тогда размер структуры составит 32 байта.

В c11 появился простой способ указания выравнивания, совместимый с будущими версиями стандарта:

1. Выравнивание представляется как неотрицательное целое число типа <span style="color:orange">_size_t_</span>.
2. Корректное выравнивание должно быть степенью двойки.

Также в c11 появился спецификатор выравнивания <span style="color:orange">__Alignas_</span>:

1. Позволяет указать, что переменная должна быть выровнена определенным образом.
> Пример в functions_objects_and_types/jokes_with_alignments.c

Строгость выравнивания:

1. Способы выравнивания упорядочены от слабых к строгим.

2. Чем строже выравнивание, тем больше его значение (т.е. больше байт).

3. Адрес, удовлетворяющий строгому выравниванию, автоматически удовлетворяет и более слабым (меньшим) выравниваниям.