# <span style="background-color:chocolate">ОБЩИЕ ЗАМЕТКИ</span><br>
<span style="background-color: green">Можно скомпилиривать как при помощи gcc, так и cc - второй создаст файл a.out. Или, как у gcc, можно добавить флаг -o и скомпилить файл с нужным именем.</span>

C имеет две потенциальные _<span style="color:orange">_среды выполнения_:
1. <span style="color:orange">_минимальную_ - freestanding</span>
2. <span style="color:orange">_полноценную_ - hosted</span><br>

<span style="background-color:red; color:black">---Минимальная среда выполнения---</span>
1. Может существовать вне ОС
2. Используется в создании встраиваемых систем
3. Предоставляет минимальный набор библиотечных функций, а объявление точки входа отличается в разных реализациях

Программы на C состоят из <span style="color:orange">_процедур (функций, методов)_</span>, которые:
1. имеют определённый тип и могут возвращять определённые значения (тип функции = тип возвращаемого значения)
2. могут принимать аргументы

# <span style = "background-color:chocolate">ВВЕДЕНИЕ В C</span>

## <span style="background-color:green">Директивы препроцессора</span><br>

<span style="color:violet">__Директива препроцессора__</span> — это специальная команда, которую препроцессор распознаёт и выполняет для предварительной обработки текста программы. Препроцессор обрабатывает исходный код до компиляции, и директивы указывают, как выполнять определённые действия. <br>
<span style="color:violet">__#include__</span> - ведет себя так, будто вместо нее подставляется содержимое указанного файла. По сути, подключает нужный файл.

## <span style="background-color:green">Стандартные библиотеки</span><br>

<span style="color:violet">__stdio.h__</span> - I/O - содержит методы ввода/вывода.<br>
<span style="color:violet">__stdlib.h__</span> - функции общего назначения.<br>

## <span style="background-color:green">Входная точка программы</span>

<span style="color:violet">__int main()__</span>  - входная точка программы<br>
<span style="color:violet">__(void)__</span> - даёт понять, что main <span style="color:orange">_ничего не принимает._</span>

Предназанчение возаращемого функцией main значения - <span style="color:orange">_указать, как завершилась программа - успешно или нет_</span>

### <span style="background-color:red; color:black">---Как происходит вход/выход в/из программы:---</span><br>

#### ВХОД 
main - входная точка, выполняемая при запуске программы
выполняется функция main в серверной среде, после запуска из командной строки или другой программы

#### ВЫХОД 
return (0 или 1, или макросы, представляющие эти значения) - выход из программы -- среда исполнения получает возврат из функции main, по которому может проверить состояние проги и определить, насколько успешен был вызов.

#### ЗАМЕЧАНИЯ 
return __value__ в main = exit(__value__) 

## <span style="background-color:green">ФОРМАТИРОВАННЫЙ ВЫВОД</span><br>

<span style="color:violet">__printf__</span> (или ее вариации) - функция, для форматированного вывода. Принимает строку, которая описывет формат вывода и произвольное количество аргументов, представляющих значения для вывода. Сама же возвращает количество выведенных символов, а при возникновении ошибки — отрицательное значение 
> <span style="color:red">АЛАРМ! ОПАСНОСТЬ! Никогда пользовательские данные не должны быть первым аргументом функции (т.е. как строку формата), т.к это может привести к утечкам памяти или инфы. Например:

```c
int main() {
    char buffer[100];
    
    // Симуляция ввода злоумышленника
    char *malicious_input = "%08x %08x %08x %08x";
    
    printf("=== УЯЗВИМЫЙ ВЫЗОВ ===\n");
    printf(malicious_input);  // ОПАСНО!
    printf("\n");
    
    printf("=== БЕЗОПАСНЫЙ ВЫЗОВ ===\n");
    printf("%s", malicious_input);  // БЕЗОПАСНО
    printf("\n");
    
    return 0;
}
```

>Вывод уязвимой версии может показать:
0041a2c0 00000001 7ffd42a8 0041a2c0
(это служебные данные из стека - УТЕЧКА ИНФОРМАЦИИ!)
</span>

### <span style="background-color:red; color:black">__Спецификаторы формата__</span> (не все)
1. <span style="color:violet">__%s__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_строку_</span>
2. <span style="color:violet">__%d__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_целое число_</span>
3. <span style="color:violet">__%f__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_число с плавающей точкой_</span>
4. <span style="color:violet">__%c__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_символ_</span>
5. <span style="color:violet">__%x__</span> - спецификатор формата, позволяющий вывести очередной аргумент - <span style="color:orange">_шестнадцатиричное число_</span>

### <span style="background-color:red; color:black">Алфавитные управляющие последовательности</span>
Необходимы для вывода неотображаемых символов. Список последовательностей:
1. <span style="color:violet">__\n__</span> - перевод строки

## <span style="background-color:green">БИБЛИОТЕЧНЫЕ МЕТОДЫ И МАКРОСЫ</span>

<span style="color:violet">__int puts(const char*)__</span>
1. записывает полученный аргумент в поток <span style="color:orange">_stdout (консоль или терминал)_</span>, добавляя к выводу '\n'
2. если во время вывода возникла ошибка, возвращается макрос EOF (представляющий отрицательное число) - иначе целое неотрицательное значение
    
<span style="color:violet">__EXIT_SUCCESS__</span>
1. макрос, зачастую имеет такое определение - #define EXIT_SUCCESS 0

<span style="color:violet">__EOF__</span>
1. макрос

## <span style="background-color:green">КОМПИЛЯТОРЫ</span>
### <span style="background-color:red; color:black">GNU Compiler Collection</span>
<span style="color:violet">__GCC__</span> — стандартный компилятор в системах Linux (также есть версии для других платформ). Поддерживает <span style="color:orange">_C_</span>, <span style="color:orange">_C++_</span>, <span style="color:orange">_Objective-C_</span> и другие языки<br>

### <span style="background-color:red; color:black">Clang</span>
<span style="color:violet">__Clang__</span> — фронтенд для компиляторов для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, созданный совместно с фреймворком LLVM. Цель проекта — <span style="color:orange">_создание замены GNU Compiler Collection (GCC)_</span>.<br>

### <span style="background-color:red; color:black">MICROSOFT VISUAL STDUIO</span>
<span style="color:violet">__Microsoft Visual Studio__</span> — не столько компилятор, сколько <span style="color:orange">_самая популярная IDE для C/C++ на Windows_</span>, но поставляется вместе с компилятором для C/C++<br>

### <span style="background-color:red; color:black">Переносимость</span>
Компиляторы не поддерживают весь спектр спецификаций стандарта C (в том числе и промежуточных). В целом, <span style="color:orange">_реа­лизации C развиваются медленно, и многие компиляторы существенно отстают от стандарта языка_</span>.

1. <span style="color:orange">_Идеал vs Реальность_</span>: Программы на C в идеале должны строго следовать стандарту для максимальной переносимости. На практике это недостижимо.

2. <span style="color:orange">_Практический подход_</span>: В реальности код пишут для конкретных реализаций (платформ), что позволяет использовать их особенности и не мешает работе на нескольких платформах.

3. <span style="color:orange">_Проблемы переносимости_</span>: Стандарт C явно выделяет пять видов поведения, которые мешают переносимости:

- <span style="color:orange">_Поведение, определяемое реализацией (во избежание проблем, нужно стремиться писать код, поведение которого не будет зависеть от конкретной реализации языка (стандарт языка и компилятор))_</span>
- <span style="color:orange">_Неуточнённое поведение (стандарт C допускает несколько вариантов работы программы, но не указывает, какой именно должен быть выбран -> т.е. все варианты корректны, но результат выполнения - разный)_</span>
- <span style="color:orange">_Неопределённое поведение_</span>
- <span style="color:orange">_Поведение, зависящее от региональных параметров_</span>
- <span style="color:orange">_Распространённые расширения_</span>

#### <span style="background-color:red">Неопределенное поведение</span>
<span style="color:violet">__Неопределённое поведение__</span> - поведение, для которого стандарт C не устанавливает никаких требований.

<span style="color:red">Сущность</span>:<br>

1. Результат непредсказуем — от некорректного вывода до сбоя программы

2. Примеры: переполнение знакового целого, разыменование некорректного указателя

3. Стандарт явно не определяет последствия таких действий

<span style="color:red">Возможные последствия:</span>:<br>

1. Непредсказуемые результаты без предупреждений

2. Поведение, специфичное для конкретной платформы

3. Аварийное завершение программы

<span style="background-color:red; color: black">__АЛАРМ!__</span> Нужно избегать неопределённого поведения, если только реализация явно не определяет его через расширения языка.</span>

# <span style="background-color:chocolate">ОБЪЕКТЫ, ФУНКЦИИ И ТИПЫ</span><br>

## <span style="background-color:green">ОБЪЕКТЫ</span>
<span style="color:violet">__Объект__</span> — это хранилище, в котором можно представлять значения. По стандарту <span style="color:orange">_ISO/IEC 9899:2018_</span>, <span style="color:violet">__объект__</span> - область хранилища данных в среде выполнения, содержимое которого может представлять значения» с примечанием: «при обращении к объекту можно считать, что он обладает определенным типом». Один из примеров объекта - <span style="color:orange">_переменная_</span>.

<span style="color:violet">__Переменная__</span> - это контейнер для значения. Они имеют объявленный <span style="color:orange">_тип_</span>, указывающий на то, какого рода объект представляет его значение, а также <span style="color:orange">_имя_</span> - идентификатор, по которому можно обратиться к созданной переменной.

У объектов есть понятие <span style="color:violet">__времени жизни__</span> или, как в других языках, <span style="color:violet">__жизненного цикла__</span> - это период выполнения программы, во время которого объект существует. Вне периода к объекту обратиться нельхя, т.к. он уже не будет существовать.

<span style="color:orange">_Время хранения_</span> определяет <span style="color:orange">_время жизни_</span> объекта.

## <span style="background-color:green">ТИПЫ</span>

<span style="color:violet">__Тип__</span> - характеристика данных, определяющая размер выделяемой для объекта памяти и представление объекта в памяти, допустимые с объектом операции и его диапозон значений.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Каждый тип в С является либо <span style="color:orange">_объектным_</span>, либо <span style="color:orange">_функциональным_</span>.

<span style="background-color:red; color: black">__АЛАРМ!__</span> Важность типа объясняется тем, что набор битов, представляющий объект определённого типа, будет иметь другое значение, если интерпретировать как объект другого типа. 

> <span style="background-color:#00a572; color: white">__Пример__</span> В IEEE 754 (стандарт IEEE для арифметических операций с плавающей запятой) число 1 можно представить как 0x3f800000 (IEEE 754–2008). Этим же набором битов, интерпретированным как целое число, можно представить число 1 065 353 216.

<span style="color:orange">_Базовые типы_</span>:

1. <span style="color: violet">int</span> - целочисленный
2. <span style="color: violet">float</span> - вещественный
3. <span style="color: violet">char</span> - символьный
4. <span style="color: violet">void</span> - пустой тип (функция с этим типом будет считаться бестиповой)

## <span style="background-color:green">ФУНКЦИИ</span>

<span style="color: violet">Функция</span> - это именованный блок кода, который выполняет одну конкретную задачу. Может быть вызвана много раз.

У функции могут быть описаны <span style="color:violet">__параметры__</span> - объекты, которые объявляются вместе с функцией и получают значения при входе в нее, а те самые значения - есть <span style="color:violet">__аргументы__</span>. В языке C передача <span style="color:orange">__аргументов__</span> при вызове происходит <span style="color:orange">_по значению_</span>; то есть когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. Изменение значений параметров в функции не влияет на значения в вызывающем коде, поскольку это разные объекты.

Если в объявлении функции после типа указан знак *, это значит, что параметр является <span style="color:orange">_указателем_</span> на объект или функцию заданного типа.

Не объекты, но имеют тип, характеризуемый возращаемым значением и числом/типами параметров.

## <span style="background-color:green">УКАЗАТЕЛИ</span>

<span style="color:violet">__Указатель__</span> - переменная, которая хранит <span style="color:orange">_адрес памяти_</span> другой переменной или функции. <span style="color:violet"> __Адрес__</span> - область памяти, в которой хранятся объекты или функции.

<span style="color:violet">__Ссылочный тип__</span> - тип указателя, определяемый типом данных, на которые он ссылается.

<span style="background-color:red; color: black">__АЛАРМ!__</span> <span style="color:orange">_Объектные указатели_</span> (то есть указатели на объект) отличаются от <span style="color:orange">_функциональных указателей_</span> (то есть указатели на функцию) => их нельзя использовать как взаимозаменямые.

```c
void swap(int* a, int* b) {
    int temp = *a;

    *a = *b;
    *b = temp;
}
```
> int temp = *a; - унарная операция * - <span style="color:violet">__операция разыменовывания__</span>, т.е. получение значения по адресу памяти, куда указывает указатель а

```c
swap(&a, &b);
```
> унарная операция & - операция взятия адреса

```c
#include <stdlib.h>
#include <stdio.h>

void swap(int*, int*);

int main(void) {
    int a = 15, b = 71;
    printf("a = %d, b = %d до вызова функции\n", a, b);

    swap(&a, &b);
    printf("a = %d, b = %d после вызова функции\n", a, b);

    return EXIT_SUCCESS;
}

void swap(int* a, int* b) { //параметры, при вызове функции, будут содержать копии аргументов, т.е. переданных адресов - имитация передачи аргументов по ссылке
    int temp = *a;

    *a = *b;
    *b = temp;
}
```

## <span style="background-color:green">ОБЛАСТИ ВИДИМОСТИ</span>
<span style="color:violet">__Область видимости__</span> - 1) блок кода, в котором возможно обращение к идентификатору. В языке C область видимости может охватывать <span style="color:orange">_файл_</span>, <span style="color:orange">_блок кода_</span>, <span style="color:orange">_функцию_</span>, <span style="color:orange">_прототип(объявление) функции_</span>. 2) регион программы, в котором идентификатор может быть использован

Область видимости определяется местом, где он объявлен:
1. <span style="color:violet">__На уровне файла__</span>. Это значит, что идентификатор доступен на уровне всего файла, где объявлен, а также во всех других файлах, где используется файл объявления. Например, в файле source.h, в самом начале файле, после объявления заголовочного файла, мы определили макрос <span style="color:orange">_nagger_</span>, и если мы подключим этот файл в source_code.c, то мы сможем этим макросом пользоваться в .c файле.
```c
//source.h
#define nagger "NAGGER" 

//source_code.h
#include <source.h>
int main() {
    char* naggers_name = nagger;
}
```

> Макрос не имеет области видмости в общем понимании этого слова, как идентификатор, поэтому вот еще пример

```c
//source.h
void swap(int*, int*);

//source_code.h
#include <source.h>
int main() {
    int a = 0;
    int b = 1;
    swap(&a, &b);
}
```
2. <span style="color:violet">__Блочная область видимости__</span>. Объявленный идентификатор доступн только в том блоке, в котором объявлен. 
```c
int main() {
    int a = 1;
    {
        int temp = 2;
    }

    int b = temp + a; //АЛАРМ!!!!!!!! ОШИБКА!!!!!!!!!
}
``` 
3. <span style="color:violet">__Область видимости в прототипе функции__</span>. Параметры в прототипе видны только в этом прототипе.
```c
int swap(int a, int b);

int main() {
    a = 0; //АЛАРМ!!!!!!!!!!!ОШИБКА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
```
4. <span style="color:violet">__Область видимости функции__</span>. Только для меток. <span style="color:orange">_Метка_</span>, объявленная в функции, видна в любом месте этой функции.
> Про метки будет инфа чуть позже<br>
> В функции, параметры этой функции и локальные переменные имеют блочную область видимости (блоком является тело функции)

Области видимости могут быть <span style="color:orange">_вложенными_</span> и находиться как внутри, так снаружи других блоков.

При объявлении одинаковых идентификаторов в <span style="color:orange">_наружней_</span> и <span style="color:orange">_внутренней_</span> областях видимости, объявленный во внутренней будет перекрвать наружнюю версию.

## <span style="background-color:green">СРОК ХРАНЕНИЯ</span>

<span style="color:violet">__Срок хранения__</span> определяет <span style="color:orange">_время жизни_</span> объекта.

Какие есть сроки хранения:

1. <span style="color:violet">__Автоматический__</span>. Время жизни объекта начинается при выполнении блока и заканчивается вместе с выполнением блока. Например, <span style="color:orange">_параметры функции_</span>.
> Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.
2. <span style="color:violet">__Статический__</span>. Таким сроком хранения обладают объекты, объявленный на уровне файла. Время жизни = <span style="color:orange">_время выполнения программы_</span>, а значения инициализируются ещё до запуска программы.
> При помощи модификатора <span style="color:orange">_static_</span> можно задать статический срок хранения даже переменным с <span style="color:orange">_блочной видимостью_</span>. Смотри файл functions_objects_and_types/jokes_with_lifetime.c
3. <span style="color:violet">__Потоковый__</span>
4. <span style="color:violet">__Выделенный__</span>